### 5.12 行为模式的讨论

#### 5.12.1 封装变化

封装变化是很多行为模式的主题。**当一个程序的某个方面的特征经常发生改变时，这些模式就定义一个封装这个方面的对象**。其他程序与这个对象交互

**通常这个对象是抽象类**，并且根据这个模式命名该对象

* 一个Strategy对象封装一个算法

  (因为算法经常改变，我们定义一个抽象类Strategy，其他程序和Strategy交互，这样封装了变化，也就可以方便的更改算法)

* 一个State对象封装一个与状态相关的行为

* 一个Mediator对象封装对象间的协议，对象间的通信封装到一个接口里

* 一个Iterator对象封装访问和遍历一个聚集对象中的各个构件的方法

这些模式描述了程序中很可能会改变的方面(Strategy：算法会改变，State：状态会改变，Iterator：遍历方式会改变)

大多数模式有两种对象：**即封装变化的新对象和使用这些新对象的原有对象**，如果不使用这些模式，通常新对象会变成已有对象难以分割的一部分。如。一个算法的代码可能被嵌入Context类中。

但不是所有的对象行为模式都像这样分割功能。如：Chain of Responsibility处理的对象坑已经存在系统中了。



#### 5.12.2 对象作为参数

**封装变化的新对象和使用这些新对象的原有对象**之间的交互常常将对象作为参数。

如：Visitor 模式中的`v.VisitCharacter(this);`

其他模式定义了一些**可作为令牌到处传递的对象。**

如[Command(5.2)]()里的`具体Command`和Memento里的`ConstraintSolverMemento`，都是令牌。Command中代表的一个请求。Memento中代表了某个特定时刻的内部状态。

且这些令牌内部的复杂状态对客户是透明的。即客户不需了解其复杂的结构。



#### 5.12.3 通信应该被封装还是被分布

[Mediator(5.5)](5.5中介者(Mediator).md)和[Observer(5.7)](5.7观察者(Observer).md)这两个都是通信的方式设计。但是这两个是竞争的。

一个通过引入Observer和Subject对象来**分布通信**，而Mediator对象则**封装**了其他对象间的通信。

Observer的目的是分布(通信)，而Mediator的目的是集中(通信在一个中介者中)。



我们发现生成可复用的Observer和Subject比生成可复用的Mediator容易一些。

Observer模式有利于Observer和Subject间的分割和松耦合，同时这将产生粒度更细，从而更易于复用的类。



#### 5.12.4 对发送者和接收者解耦

当合作的对象直接互相引用时，他们变得相互依赖，这可能会对一个系统的分层和重用性产生负面影响。

**命令、观察者、中介者、职责链**这些都涉及如何对发送者和接收者解耦。但是它们又有不同的权衡考虑。

**命令模式**，见例1：[复制粘贴](code/5.2命令/复制粘贴)。使用一个Command对象来定义一个发送者(Application)和一个接收者(Document)之间的绑定关系，从而支持解耦。

Command对象提供了一个提交请求的简单接口(Execute操作)。将**发送者(Program)和接收者(Document)**之间的连接定义在一个单独的对象使得该发送者可以与不同的接收者一起工作。

如果不这样的话，肯定就要在Program里添加定义方法并且依赖接收者(Document)。

这就将发送者与接收者解耦，使发送者更易于复用。

可以复用Command对象，用不同的发送者参数化一个接收者。

**观察者模式**，通过定义一个接口通知目标中发生的改变，从而将发送者(目标)与接收者(观察者)解耦。当对象间有数据依赖时，最好用观察者模式来对它们解耦。

**中介者模式**，例1：[对话框和各组件](code/5.5中介者/对话框和各组件) 让对象通过一个Mediator对象间接互相引用，从而对它们解耦。

    public override void WidgetChanged(Widget theChangeWidget)
    {
        if (theChangeWidget == _fontList)
        	//....
        else if(theChangeWidget == _ok)
        	//....
    }
中介者模式可以减少一个系统中的子类生成，因为它将通信行为集中在一个类中，而不是分散到各个子类中。



#### 5.12.5 总结

各个行为设计模式之间是相互补充和相互加强的关系。

如一个职责链中的类可能包括至少一个[Template Method(5.10)](5.10模板方法(Template method).md)的应用。













