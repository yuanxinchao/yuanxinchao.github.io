* 3.2生成器.md   ------- Composite通常是用Builder生成的。

* 3.3工厂方法(Factory Method).md 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候

* 3.3工厂方法(Factory Method).md   连接平行的类层次

* 3.4 PROTOTYPE（原型）  大量使用Composite和Decorator模式的设计通常也可从Prototype模式处获益。

* 4.1 ADAPTER(适配器)——类对象结构型模式

  使用抽象对象

  使用代理对象

  参数化的适配器

* 4.1 ADAPTER(适配器)——类对象结构型模式

  模式Bridge(4.2)的结构与对象适配器类似，但是Bridge模式的出发点不同：Bridge目的是将接口部分和实现部分分离，从而对它们可以较为容易也相对独立的加以改变。而Adapter意味着改变一个已有对象的接口。

  Decorator(4.4)模式增强了其他对象的功能而同时又不改变它的接口。因此decorator对应用程序的透明性比适配器要好。结果是decorator支持递归组合，而纯粹使用适配器是不可能实现这一点的。

  模式Proxy(4.7)在不改变它的接口的条件下，为另一个对象定义了一个代理。

* 4.4 DECORATOR(装饰) 将Decorator看作一个对象的外壳，他可以改变这个对象的行为(转发前后+操作)，另外一种方法是改变对象的内核。例如 Strategy模式

  Component类很庞大时，策略也可以很小。
  
* 5.2 命令模式 可以使用Memento模式来让该Command访问这些信息而不暴露其他对象的内部信息。

* 5.6 MEMENTO(备忘录)——对象行为型模式  基于备忘录的迭代接口