### 5.11 VISITOR(访问者)——对象行为型模式

























例1：[拼写检查](code/1.设计一个文档编辑器/VisitorSpace)





#### 1.意图

表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作(`SpellingCheckingVisitor`)。

#### 2.动机

例1中，我们需要对每个Glyph节点进行拼写检查和添加连字符等功能。这需要对不同的节点进行不同的处理。

直觉上，如果要添加这两个功能，我们可能会在每个Glyph节点上添加诸如`CheckSpell、CheckHyphenation`等方法，但是这些操作分散到各个节点类会导致整个系统难以理解、维护和修改。而且增加新的操作也需要为每一个类都添加新的方法。

如果可以独立地增加新的操作(`SpellingCheckingVisitor`)，并且使节点类(Glyph,Character,Image)独立于这些操作，将会好一点。



> 解决办法：我们将每一个节点类中相关的操作包装在一个独立的对象xxVisitor(`SpellingCheckingVisitor`)中，并且在遍历Glyph节点时，将xxVisitor传递给当前访问的节点(如Character)，当一个节点接受该访问者(xxVisitor)时，该节点向访问者(xxVisitor)发送一个包含自身类的请求(如`v.VisitCharacter(this);`)。访问者为该节点执行<span style="color:red">操作</span>(即`SpellingCheckingVisitor`里`VisitCharacter`方法里包裹的代码)。

上面这个逻辑就将<span style="color:red">操作</span>从节点里移到了xxVisitor中。**这样在节点中增加<span style="color:red">操作</span>(方法)就可以通过增加Vistor子类来解决。**



#### 4.适用性

以下情况使用Visitor模式：

* 一个对象结构包含很多类对象(节点)，他们有不同的接口，而你想对这些

