## 红黑树

​	一棵红黑树是满足下面**红黑性质**的二叉搜索树。它在每个结点上增加了一个存储位来表示结点的**颜色**，可以是**RED**或**BLACK**。通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束，红黑树确保没有一条路径会比其他路径长出2倍，因而是近似于**平衡的**。

#### 性质

1. 每个结点或是红色的，或是黑色的。
2. 根节点是黑色的
3. 每个叶节点($NIL​$)是黑色的。
4. 如果一个结点是红色的，则它的两个子结点都是黑色的。
5. 对每个结点，从该结点到其所有后代叶节点的简单路径上，均包含相同数目的黑色结点。

从某个结点$x​$出发(不含该结点)到达一个叶结点的任意一条简单路径上的黑色结点($Nil​$也视为黑色结点)个数称为该结点的**黑高(black-height)**，记为$bh(x)​$。根据性质5，每个结点的黑高是一个确定值。定义红黑树的黑高为其根结点的黑高。

如有以下红黑树，则其黑高 bh = 2,N为一个颜色为黑的结点代表空结点， 

```
		  N
          |
          ❶               
        /    \
       ②       ❸		   
     /   \    /  \
    ❹     ❺  N    N		   
  /  \  /  \
 N   N N    N 

bh(❶) = bh(②) = 2
bh(❸)=bh(❹)=bh(❺)=1
```

内部结点：不包括$Nil​$的结点

> **引理：一棵有n个内部结点的红黑树的高度至多为2lg(n+1)。**

证明：假如一个树黑高为$h_b​$，则其最少包含$2^{h_b} -1​$个内部结点，因为黑高为$h_b​$意味着根节点到叶结点(简单路径)经过的黑色结点为$h_b​$个。则这个二叉堆在高度为0-$h_b​$的范围内是满结点的，所以结点最少包含$2^{h_b} -1​$

因为$n \geq 2^{h_b}-1​$  ,   $ h \leq 2{h_b}​$ (性质4)

 所以$h \leq 2lg(n+1)​$

#### 旋转

​	搜索树操作`TREE-INSERT`和`TREE-DELETE`在含$n$个关键字的红黑树上，运行花费时间为O(lgn)。由于这两个操作对树做了修改，结果可能违反之前列出的红黑树性质。为了维护这些性质，必须要改变树中某些结点的颜色以及指针结构。

指针结构的修改是通过**旋转(ratation)**来完成的，这是一种能保持二叉搜索树性质的搜索树局部操作。

![](pic/7.png)

旋转后不会破坏二叉搜索树的性质但是有可能破坏红黑树的性质。所以还需要其他操作。

旋转操作代码如下：执行旋转操作时默认x，y都不为空。 

```c#
//左旋和右旋都默认 x，y结点不为Nil
public void LEFT_ROTATE(Node<T> x)
{
    var y = x.right;
    x.right = y.left;
    if (y.left != Nil)
        y.left.parent = x;
    y.parent = x.parent;
    if (x.parent == Nil)
        head = y;
    else if (x == x.parent.left)
        x.parent.left = y;
    else
        x.parent.right = y;

    y.left = x;
    x.parent = y;
}

public void RIGHT_ROTATE(Node<T> y)
{
    var x = y.left;
    y.left = x.right;
    if (x.right != Nil)
        x.right.parent = y;
    x.parent = y.parent;
    if (y.parent == Nil)
        head = x;
    else if (y == y.parent.left)
        y.parent.left = x;
    else
        y.parent.right = x;
    x.right = y;
    y.parent = x;
}
```
##### RB-INSERT(插入结点)

我们可以在O(lgn)时间内完成向一棵含n个结点的红黑树中插入一个新节点。逻辑和二叉搜索树的TREE_INSERT差不多，但是为了保证红黑性质能够继续保持，我们调用一个辅助程序**RB-INSERT-FIXUP**来对结点重新着色并旋转

```c#
public void RB_INSERT(Node<T> z)
{
    var y = Nil;
    var x = head;
    while (x != Nil)
    {
        y = x;
        if (compare(z.value, x.value) < 0)
            x = x.left;
        else
            x = x.right;
    }
    z.p = y;
    if (y == Nil)
    {
        head = z;
    }
    else if(compare(z.value,y.value) < 0)
    {
        y.left = z;
    }
    else
    {
        y.right = z;
    }
    z.left = Nil;
    z.right = Nil;
    z.color = RED;
    BR_INSERT_FIXUP(z);
}

public void BR_INSERT_FIXUP(Node<T> z)
{
    while (z.p.color == RED)
    {
        if (z.p == z.p.p.left)
        {
            var y = z.p.p.right;
            if (y.color == RED)
            {
                z.p.color = BLACK;
                y.color = BLACK;
                z.p.p.color = RED;
                z = z.p.p;
            }
            else

            {
                if (z == z.p.right)
                {
                    z = z.p;
                    LEFT_ROTATE(z);


                }

                z.p.color = BLACK;
                z.p.p.color = RED;
                RIGHT_ROTATE(z.p.p);
            }
        }
        else if (z.p == z.p.p.right)
        {
            var y = z.p.p.left;
            if (y.color == RED)
            {
                z.p.color = BLACK;
                y.color = BLACK;
                z.p.p.color = RED;
                z = z.p.p;
            }
            else
            {
                if (z == z.p.left)
                {
                    z = z.p;
                    RIGHT_ROTATE(z);
                }

                z.p.color = BLACK;
                z.p.p.color = RED;
                LEFT_ROTATE(z.p.p);
            }
        }
    }
    head.color = BLACK;
}
//左旋和右旋都默认 x，y结点不为Nil
public void LEFT_ROTATE(Node<T> x)
{
    var y = x.right;
    x.right = y.left;
    if (y.left != Nil)
        y.left.p = x;
    y.p = x.p;
    if (x.p == Nil)
        head = y;
    else if (x == x.p.left)
        x.p.left = y;
    else
        x.p.right = y;

    y.left = x;
    x.p = y;
}

public void RIGHT_ROTATE(Node<T> y)
{
    var x = y.left;
    y.left = x.right;
    if (x.right != Nil)
        x.right.p = y;
    x.p = y.p;
    if (y.p == Nil)
        head = x;
    else if (y == y.p.left)
        y.p.left = x;
    else
        y.p.right = x;
    x.right = y;
    y.p = x;
}
```
在调用`RB_INSERT`插入一个结点$z​$后,有可能会破坏红黑树的性质。

我们将插入的结点$z$置红色，所以135性质得以保证，则有可能破坏其他性质的情况为

* 插入后$z​$为根节点，破坏性质2
* 插入后$z​$的父节点为红色，破坏性质4

如果破坏性质4，如下图

  

![](pic/8.png)

插入后如果破坏性质4：

1. $z$父节点一定是红色且不是根节点。(因为性质2根节点不能为红)
2. 如果$z$的叔结点为红色跳转至3，如果$z$的叔结点为黑色跳转至5。
3. 将$z​$的父节点，叔结点改为黑色，$z​$的祖父结点改为红色，z = z的祖父结点，
4. 这时，如果破坏性质2，即z是根节点，则z结点直接置黑结束。(根节点由红变黑不会破坏红黑性质) ，如果破坏性质4，则跳转到1。
5. 此时$z$的父节点为红色，$z$的祖父结点不为$Nil$且一定为黑色(性质4)，
6.  假设$z​$在$z​$的祖父结点左侧，如果$z​$是右孩子，如上图情况2，左旋$z.parent​$(各个结点的黑高不变)，然后右旋$z​$的祖父，如上图情况3，随后调整颜色
7. $z$在$z​$的祖父结点右侧同理

##### RB-DELETE(删除)

