## 大端小端
#### 1.什么是大端,什么是小端:
**所谓的大端模式**，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；

**所谓的小端模式**，是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。
#### 2.为什么会有大小端:
为什么会有大小端模式之分呢？这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。
#### 3.大小端在内存中的存放方式举例:
 例如，16bit宽的数0x1234在Little-endian模式CPU内存中的存放方式（假设从地址0x4000开始存放）为：  

内存地址|0x4000|0x4001
----|----|---
存放内容|0x34|0x12
而在Big-endian模式CPU内存中的存放方式则为：  

内存地址|0x4000|0x4001
----|----|---
存放内容|0x12|0x34
#### 4.使用  
在使用字节存储数据时，要与服务器统一好用大端或小端。  
**栗子：**  

	/* 读取整形, 大端*/
    public int ReadInt()
    {
        //解包数据
        int i = (_buf[_pos] << 24) + (_buf[_pos + 1] << 16) + (_buf[_pos + 2] << 8) + (_buf[_pos + 3]);
        _pos += 4;
        return i;
    }
 这里使用的是大端，所以对整型数据的读取要将低字节左移。

 	/*写入整形数据，大端*/
    public void WriteInt(int i)
    {
        SetInt(_len, i);
        _len += 4;
    }

    public void SetInt(int index, int value)
    {
        byte[] b = BitConverter.GetBytes(value);
        if (BitConverter.IsLittleEndian)
        {
            Array.Reverse(b);
        }
        Array.Copy(b, 0, _buf, index, 4);
    }
在写入整形时用函数`BitConverter.IsLittleEndian`判断，如果是按小端存入的则要调换顺序.