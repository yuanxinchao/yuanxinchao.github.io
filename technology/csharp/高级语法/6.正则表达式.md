## 正则表达式
#### 1.各字符含义
![](pic/1.png)
![](pic/2.png)

栗子：  

* ^[0-9]+$   从开头^到结束$ 出现一次或多次+  ,0-9的 数字
* ()   标记一个子表达式的开始和结束位置
* ?  匹配前面的子表达式零次或一次，或指明一个非贪婪限定符  

#### 2.贪婪与非贪婪
`*、+和?限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。`例如，您可能搜索 HTML 文档，以查找括在 H1 标记内的章节标题。该文本在您的文档中如下：
栗子：  
`<H1>Chapter 1 - 介绍正则表达式</H1>`  
**贪婪：**下面的表达式匹配从开始小于符号 (<) 到关闭 H1 标记的大于符号 (>) 之间的所有内容。`/<.*>/`  
**非贪婪：**如果您只需要匹配开始和结束 H1 标签，下面的非贪婪表达式只匹配` <H1>`。 `/<.*?>/`  

通过在 *、+ 或 ? 限定符之后放置 ?，该表达式从"贪心"表达式转换为"非贪心"表达式或者最小匹配。

#### 4.平衡组/递归匹配
有时我们需要匹配像 ( 100 * ( 50 + 15 ) ) 这样的可嵌套的层次性结构，这时简单地使用 \(.+\)则只会匹配到最左边的左括号和最右边的右括号之间的内容.假如原来的字符串里的左括号和右括号出现的次数不相等，比如 ( 5 / ( 3 + 2 ) ) )，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？
#### 3.C#中的使用
1.新建一个模式为单行，非贪婪的正则表达式：
`Regex RegexKey = new Regex(@"(你好)(\d+)(\S+)", RegexOptions.Singleline);`
2.和一个字符串msg进行匹配：  

	string msg = "aa你好123456dsad bb你好654321hello";
	MatchCollection mc = RegexKey.Matches(msg);  
3.获取匹配结果：

    for (int i = 0; i < mc.Count; i++)
    {
        var m = mc[i];
        Console.WriteLine("m.Index= " + m.Index); 
        Console.WriteLine("m.Value= " + m.Value);
        Console.WriteLine("m.Groups[0].Value= " + m.Groups[0].Value);
        Console.WriteLine("m.Groups[1].Value= " + m.Groups[1].Value);
        Console.WriteLine("m.Groups[2].Value= " + m.Groups[2].Value);
    }
    Console.WriteLine("origin= "+msg);
这里获取的匹配结果里的match属性有，匹配字串的index，长度length等。`m.Value`和`m.Groups[0].Value`一样都是对应这个正则的匹配，而`m.Groups[1].Value`和`m.Groups[2].Value`等等，则是对应第一和第二 **()**里匹配的内容，往后类推。结果如图：  

![](pic/18.png)
---
正则坑1：  
要个需求是对坐标加颜色并且获取坐标值，所以要匹配坐标。  
正则表达式写为：

	private static readonly Regex s_CoordRegex =
        new Regex(@"(\[)?([\d]{1,4})[,\.\uff0c\u3001]([\d]{1,4})(\])?", RegexOptions.Singleline);  
\d 是匹配数字，表面看来好像并无问题，但是在执行如下代码  

	foreach (Match match in s_CoordRegex.Matches(outputText))
    {
            var x = Convert.ToInt32(match.Groups[2].Value);
            var y = Convert.ToInt32(match.Groups[3].Value);
			...
	}
有时会报错，  
![](pic/17.png)  
诶？为什么Input string的format不对呢，这是因为对于\d的匹配不仅会匹配到0-9(半角)也会匹配到０-９(全角)，注意两个是不一样的。在GBK码表现为为**0-9(半角)->30-39(16进制)**，**０-９(全角)->A3B0-A3B9** 。在Unicode码表现为**(半角0-9)->(\u0030-\u0039)**,**(全角０-９)->(\uff10-\uff19)**，哎呀，不管什么码，就是全角格式的０-９啦，  
**然后**，如果是有个全角坐标如１２，３４ Convert时就会报格式错。  
解决方案1：将全角替换为半角

    public static string ToDBC(string input)
    {
        char[] c = input.ToCharArray();
        for (int i = 0; i < c.Length; i++)
        {
            if (c[i] >= 65248 + 48 && c[i] < 65248 + 57)
                c[i] = (char)(c[i] - 65248);
        }
        return new string(c);
    }
解决方案2：正则只匹配半角0-9，如下代码

	private static readonly Regex s_CoordRegex =
        new Regex(@"(\[)?([\u0030-\u0039]{1,4})[,\.\uff0c\u3001]([\u0030-\u0039]{1,4})(\])?", RegexOptions.Singleline);
	最好方案为
	private static readonly Regex s_CoordRegex =
        new Regex(@"(\[)?([0-9]{1,4})[,\.\uff0c\u3001]([0-9]{1,4})(\])?", RegexOptions.Singleline);
	//注意上面是半角0-9