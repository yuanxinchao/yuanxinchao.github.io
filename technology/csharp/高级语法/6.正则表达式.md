## 正则表达式
#### 1.各字符含义
![](pic/1.png)
![](pic/2.png)

栗子：  

* ^[0-9]+$   从开头^到结束$ 出现一次或多次+  ,0-9的 数字
* ()   标记一个子表达式的开始和结束位置
* ?  匹配前面的子表达式零次或一次，或指明一个非贪婪限定符  

#### 2.贪婪与非贪婪
`*、+和?限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。`例如，您可能搜索 HTML 文档，以查找括在 H1 标记内的章节标题。该文本在您的文档中如下：
栗子：  
`<H1>Chapter 1 - 介绍正则表达式</H1>`  
**贪婪：**下面的表达式匹配从开始小于符号 (<) 到关闭 H1 标记的大于符号 (>) 之间的所有内容。`/<.*>/`  
**非贪婪：**如果您只需要匹配开始和结束 H1 标签，下面的非贪婪表达式只匹配` <H1>`。 `/<.*?>/`  

通过在 *、+ 或 ? 限定符之后放置 ?，该表达式从"贪心"表达式转换为"非贪心"表达式或者最小匹配。

#### 4.平衡组/递归匹配
有时我们需要匹配像 ( 100 * ( 50 + 15 ) ) 这样的可嵌套的层次性结构，这时简单地使用 \(.+\)则只会匹配到最左边的左括号和最右边的右括号之间的内容.假如原来的字符串里的左括号和右括号出现的次数不相等，比如 ( 5 / ( 3 + 2 ) ) )，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？
#### 3.C#中的使用
1.新建一个模式为单行，非贪婪的正则表达式：
`private static readonly Regex _inputRegex = new Regex(@"<Color.*?Color>", RegexOptions.Singleline);`
2.和一个字符串text进行匹配：  
`MatchCollection matchs = _inputRegex.Matches(_text.text);`  
3.获取匹配结果：

	foreach (Match match in _inputRegex.Matches(_text.text))
    {
        _startIndex = match.Index*6 + 1;
        _endIndex = (match.Groups[0].Value.Length)*6 + _startIndex - 1;
    }
这里获取的匹配结果里的match属性有，匹配字串的index，长度length等。`match.Groups[0]`里的索引即是当正则表达式里有()匹配时，代表其中按括号顺序里的内容

