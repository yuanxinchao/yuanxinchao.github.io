### 1.介绍

png格式提供了便携合法无负担的，压缩良好的，详细标准说明的无损位图文件。

尽管最初发展png的目的是替代gif，对于开发者用小成本提供了gif没有的有用特性的设计。

png保留的gif特性

* 调色板索引色 到256色
* 流式读取：运行时渐进显示图片
* 渐进式显示：在通信链路上接收时，可以先显示一个合适的图像，先快速显示一个低分辨率的图片然后逐步改善细节
* 透明度：图片的一部分可以被标记为透明，创建一个非矩形图片的效果
* 辅助信息：文本注释和其他数据可以被存储在图片文件里
* 完全独立于硬件和平台
* 无损压缩

gif没有的png新特性

* 真彩色，一个像素最多48位存储
* 灰度图，最多到一个像素16位
* 完整的透明通道，(通用透明蒙版)
* gamma信息，支持自动校正量度对比度显示图片。
* 可信赖的，直接检测文件错误
* 渐进式显示时更快地初始显示

png设计目的：

* 简单编写，开发者可以简单的实现png
* 合法无负担，算法没有专利困扰。
* 压缩良好



* 可交换的：任何符合标准的png都可以被解码
* 灵活：png格式允许将来拓展和私有附件，不会损坏基础png的可交换能力
* 健壮性：设计上支持文件完整性检查和简单快速的传输错误检测。

这个标准的最主要部分是给出了文件格式的定义和编码解码行为的建议。附录给出了设计的原理。尽管原理不是正式说明的一部分，但是可以帮助理解设计原理。正文中的交叉引用指向了原理相关的部分，附录提供了gamma的教程，颜色理论和其他有用的材料。

本规范中的"must"代表强制的要求，"should"代表了推荐的行为

PNG发音成"ping"

### 2.数据表示

本章讨论png中的数据表示形式，和图像数据的预期表现

#### 2.1 整数和字节顺序

所有的整数都需要不止一个字节显示，顺序为：最重要的字节在前面，

#### 2.2 颜色值

可以用灰度和RGB。灰度数据代表亮度，RGB数据代表校准过的颜色信息(cHRM块)或者未校准的依赖设备颜色(如果没有cHRM块)。所有的颜色值范围是0(代表黑色)到取样深度的最大值($(2^{sampledepth})-1$)。

取样值不一定是线性的，gAMA块指定了来源设备的gamma性质，显示器再给与合适补偿

有些png不支持的精度(如5位的真彩色) 会在放大到下一级别支持的精度(8位)，这种放大是可逆的，没有数据丢失，也减少了解码器需要处理的不同精度的数量。

#### 2.3 图片布局

概念上，一个PNG图片是一个矩形像素数组，从左到右扫描一行，从上到下扫描多行显示，(如果是渐进式显示，数据也许会使用不同的顺序传输)。每个像素的大小取决于位深度，位深度是图片每次采样比特位的数量。

支持三种像素类型

* 调色板索引色，取样的颜色是一个指向调色板的索引。图片的位深度决定了调色板条目的最大值而非调色板的颜色精度
* 灰度图取样的一个像素是一个灰度值，0最小为黑色，位深度的最大值是白色
* 真彩色的一个像素是三次取样的结果，r，g，b，位深度指定了每次采样的最大值而非像素大小。



灰度和真彩色也可以包含透明度。

像素总是按行打包，值小于一个字节的像素也会用占用一个字节，最左边的像素打包成字节顺序会靠前。

PNG允许的多通道采样位数只有8位和16位。所以多通道的一个像素永远不会被打包成一个字节。16位的取样是以大端模式(MSB)保存。

行扫描总是从以字节为单位，一个像素少于8位，且一个字节储存的像素数不能被一行像素数目整数，那么最后一个字节的最低几个比特位是被浪费的，浪费的位不会说明。例 一行九个像素 一个字节存两个像素， 需要5个字节，最后一个字节的最低四位是浪费的

过滤类型字节会被添加到每行的开头，不是图像数据的一部分但是压缩步骤需要用到



#### 2.4 透明通道

透明通道在每个像素的基础上代表透明信息，灰度和真彩的png都可以添加透明通道，

0代表完全透明，$2^{bitdepth}-1$代表完全不透明，中间的值意味着部分透明可以和背景图片组合然后提供一个混合图。因此，alpha实际是一个一个像素的不透明度。

因此，透明通道实际是一个像素的不透明度，但是大多数人都认为是透明度，这里我们继续这个习惯。

图片可以包含8或16位透明通道，不可以少于8位。透明通道的采样和图片取样使用相同的位深度表示，每个像素的透明度采样紧跟在灰度或rgb采样之后存储。

像素的色彩值不被像素alpha影响，这个规则被称为非关联"unassociated" or 非预乘"non-premultiplied"。(另一个常用的技术是取样值预先乘上alpha分量然后存储，实际上，这种情况是默认和黑色背景混合，PNG不使用预乘alpha)

透明度控制也可以不使用整个alpha的成本，在索引色彩图上，alpha值可以被调色板列出然后引用。灰度或真彩色图里，可以使用tRNS块标记单个像素值的透明度。

如果没有alpha通道也没有tRNS块，图片中的所有像素就会被认为全不透明的。



#### 2.5 过滤器

PNG允许图片数据在压缩前对其过滤。过滤可以改善数据的压缩率。过滤步骤并不减小数据的大小。所有PNG过滤都是无损的。

PNG定义了几个不同的过滤算法，包括"None"即无过滤。过滤算法是被指定对于行扫描通过过滤类型字节在过滤过的扫描行在预压缩数据流。

预压缩数据流中过滤扫描线之前的过滤类型字节指定了过滤算法

一个好的编码器可以在不同行之间切换过滤类型，选择哪种过滤类型取决于编码器。



#### 2.6  交错数据顺序

一个渐进式类型显示的PNG图片需要使用交错interlaced顺序存储。这个特性的目的是允许图片在运行中慢慢显现。交错类型存储稍微增大了文件大小，但是给了用户一个更加快速的重要显示方式。当然，解码器也需要能够读取交错类型的图片，不管是否使用渐进式显示方式。

当使用交错类型0，像素是按照从左到右，每行从上到下存储的(无交错)。

交错类型1，就是以作者Adam M Costello命名的算法Adam7，由7次传输组成，每次传输一个像素的子集。从左上角开始，通过在整个图像上复制以下8×8模式来定义每个像素的传输过程。

```
         1 6 4 6 2 6 4 6
         7 7 7 7 7 7 7 7
         5 6 5 6 5 6 5 6
         7 7 7 7 7 7 7 7
         3 6 4 6 3 6 4 6
         7 7 7 7 7 7 7 7
         5 6 5 6 5 6 5 6
         7 7 7 7 7 7 7 7
```

每次传输过程，选中的像素是按照行内从左到右，行间从上到下的顺序传输的。例如，第2次传输，是传输(0,4),(8,12),(16,20)等像素点。(左上为0,0)。最后一次传输包含1,3,5等单数行的所有数据。

每次传输的数据就像是一个适当尺寸的完整数据。例如，如果一个16*16的图片，第3次传输包含两行，每行包含4个像素。当像素少于8位，上面的每一行像素会被补足成一个整型的字节数。过滤是减少图片大小的常用方法，过滤类型的字节是在每行像素传输之前就被传输。值得注意的是，定义传输顺序是为了扫描线有相同数量的像素。这对于某些过滤器的正确应用是必要的。

注意：如果图片包含少于5列或行，一些通道会全空。编码和解码器应该正确处理这种情况。特别是，过滤类型存储的字节只和非空扫描线有关。空传输没有过滤类型字节。

#### 2.7 Gamma校正

通过gAMA块可以指定图片相对于原始场景的gamma值，强烈建议显示程序使用这些信息。加上他们使用的显示设备和房间照明的信息，以尽可能接近地再现原始作者所看到的图像的方式将图像显示在显示器上。

Gamma校正不会应用到alpha通道，alpha取样永远代表一个全不透明的线性分量。

对于一个高精度应用，PNG图片的RGB数据的精确色调和饱和度可以通过cHRM块指定，比起gamma校正可以有更精确的色彩。

#### 2.8 文本

一个PNG文件可以存储图片有关文本，如图片描述和版权声明。key值时文本代表的含义。 推荐使用ISO 8859-1 (Latin-1) 编码文本(一个字节)，这个字符集是7位ASCII的超集。

字符编码不在 Latin-1 中不应使用，因为它们没有独立于平台的含义。如果一个非 Latin-1 编码出现在PNG的文本中，平台和解码器的不同，解释也不同。一些系统甚至不能够显示Latin-1中所有的字符，但是最先进的系统可以。



### 3 文件结构

PNG文件由一个PNG签名和一些块组成。这张定义了签名结构和基础块。单独的块类型下章介绍。

#### 3.1 PNG文件签名

PNG文件最开始的8个字节总是下面的值

```
  137 80 78 71 13 10 26 10  //十进制
```

这个签名意味着文件剩下的部分包含了一个PNG图片，由一系列的块组成，起始块是IHDR，结束块是IEND。

#### 3.2 块的布局

四部分

**长度**：4字节无符号整型记录块数据的大小(不包含长度，块类型和CRC)。0是有效的长度。尽管编码和解码器都会将其解释成无符号数，但是数据长度不应该超过$(2^{31})-1$

**块类型**：4字节块类型。为了描述方便和校验，类型码由严格的大小写ASSCII字母组成。块的其他的命名约定会在下节讨论。

**块数据**：如果有的话是根据块类型确定格式。长度也可以是0

**循环冗余检测**(CRC)：一个根据前面块中字节数得到的4字节CRC。包含**块类型**和**块数据**，不包含长度。CRC总是有，就算块不包含数据。

块数据长度可以为任意字节。因此，实现者不能假设块在大于字节的任何边界上对齐。

块可以在块类型放置顺序的规则下按照任意顺序排放。(IHDR必须在第一个，IEND必须出现在最后。IEND块作为一个文件结束的标记)。 相同类型的块在允许的情况下可以出现多次。

#### 3.3 块命名规则

块类型编码需要在即使解码器识别不出类型码时也能理解块的属性。这条规则为了安全灵活扩展PNG格式，允许解码器再遇到识别不出的块类型时决定如何做。如果解码器识别出了块类型，那么就关心命名规则了(大小写)

4字节类型码，每个字节的第5位(从0开始)被用来表示块属性。大写字母的ASCII二进制表示时第5位都为0，小写字母则为1，这意味着可以通过每个字母的大小写来读出块属性，但是解码器应该通过读取特定位(第5位)来解释未知块的属性。判断大小写是没有效率的，在特定语言地区定义大小写时使用这种判断甚至是错误的。

值得注意的是位代表的属性是块名携带的信息，对于任何块都是固定的。因此。TEXT和Text不是属性不同的块，而是毫无联系的两类块类型码。解码器应该通过单纯的比较四个字节来识别块类型，而不是转换块类型的大小写。

属性位的语义为：

* 辅助位：第1个字节的第5位

  0(大写) 重要块，  1(小写) 辅助块

  对于展示文件内容辅助块不是必须的。

  解码器遇到识别不出的辅助块可以安全的忽略。如tIME 块。

  为了成功展示文件内容，重要块是必须的

  解码器遇到识别不出的重要块必须告诉用户遇到了不能解析的块信息。如 IHDR块

* 私有位：第2个字节的第5位

  0(大写) 公有，  1(小写) 私有

  公有块指的是PNG规范中或在PNG专用公共块类型列表中的。应用为了某个目的定义自己的私有块。私有块名称的第2个字母必须是小写字母，共有块则是大写字母。解码器可以不用知道块的公有私有属性，，因为它没有功能意义。这种规则只是为了确保公共块名和私有块名不会冲突的一种管理便利。

* 保留位：第3个字节的第5位

  必须是0(大写)，来确认是PNG的文件

  为了将来的拓展的保留位，目前必须要大写。遇到小写解码器可以忽略该块。

* 拷贝安全位：第4个字节的第5位

  0(大写) 拷贝不安全，  1(小写) 拷贝安全

  纯PNG解析器不用关心这个位，但是如果是PNG编辑器，这个标志位定义了如何合适处理识别不出的块。

  如果该位为0，代表这个块是独立于图片数据的。如果程序改变了png中重要块的数据，未识别出的拷贝不安全块不应该输出到PNG文件里。(当然，如果程序识别出了该块，可以选择输出一个合适的格式) 。 这里可能是某些拷贝不安全块定义了一些全局设置(或者依赖其他重要块)，当更改了其他重要的块，而不调整某块可能会导致输出的PNG显示不对。

  一个PNG编辑器，总是允许去拷贝一些未识别的辅助块，这就意味着，不重要块之间不能有依赖

  PNG编辑器识别不出重要块应该直接报错，中断处理PNG的进程。这个拷贝安全位是**为辅助块设计的**。重要块的该位应该一直设置为0。即重要块的第一个字母和最后一个一定大写。

举例

```
         bLOb  <-- 32 bit chunk type code represented in text form
         ||||
         |||+- Safe-to-copy bit is 1 (lower case letter; bit 5 is 1)
         ||+-- Reserved bit is 0     (upper case letter; bit 5 is 0)
         |+--- Private bit is 0      (upper case letter; bit 5 is 0)
         +---- Ancillary bit is 1    (lower case letter; bit 5 is 1)

      这个名字代表了 辅助，公开，拷贝安全块 
```

#### 3.4 CRC算法

块CRC的值是使用标准CRC方法计算得出的，包括预处理和后处理，根据ISO 3309 [ISO-3309] 或 ITU-T V.42的规范。

CRC多项式是

$ x^{32}+x^{26}+x^{23}+x^{22}+x^{16}+x^{12}+x^{11}+x^{10}+x^8+x^7+x^5+x^4+x^2+x+1$

32位的CRC寄存器初始化为1，然后从最低有效位(1)到最高有效位(128)处理数据的每个字节。所有数据被处理后，CRC寄存器值取补码。这个值是使用大端(MSB)存储的，为了拆分成字节，32位CRC的最低有效位被定义为x^31这一项的系数。

实际上计算CRC会使用一个计算好的表来加速计算。

### 4.  块规范

这一章定义了PNG块的标准类型

#### 4.1 重要块

所有实现PNG的都要理解和正确呈现标准重要块。一个有效的PNG图片应该包含IHDR块，一个或多个IDAT块，一个IEND块。

##### 4.1.1 IHDR图片头

IHDR块必须放在第一个，它包含

```
Width:              4 bytes
Height:             4 bytes
Bit depth:          1 byte
Color type:         1 byte
Compression method: 1 byte
Filter method:      1 byte
Interlace method:   1 byte
```

宽和高的单位是图片像素尺寸。4字节整型。0是不合法的值，最大值为$2^{31}-1$的无符号整型。

位深是一个单字节整型，给出每次采样或调色板索引的占的位数，有效的值为 1,2,4,8或16 ，在不同颜色类型下，值有些值是无效的。

颜色类型是一个单字节整型，用来描述图像数据。颜色类型码是接下来值的和(位与)，1(调色板)，2(色彩使用)，4(透明度)。有效的值是0,2,3,4,和6

对每个颜色类型施加位深限制是为了简化编解码然后阻止一些压缩不好的组合。解码器应该支持合法的位深和颜色类型组合，允许的组合是

```
Color    Allowed    Interpretation
Type    Bit Depths
0       1,2,4,8,16  Each pixel is a grayscale sample.
2       8,16        Each pixel is an R,G,B triple.
3       1,2,4,8     Each pixel is a palette index; a PLTE chunk must appear.
4       8,16        Each pixel is a grayscale sample,followed by an alpha sample.
6       8,16        Each pixel is an R,G,B triple,followed by an alpha sample.
```

除了颜色类型3(调色板)采样位深是8，其他的颜色类型采样深度是和位深一样的。

压缩方法是一个单字节整型，代表图片的压缩方法。目前只有压缩方法0(deflate/inflate压缩方法)被定义。所有标准的png图片应该使用这种方案压缩。这个压缩方法字段用于将来可能的扩展或专有变体。解码器应该检查这个字节如果它是一个无法识别的码则报错。

过滤方法是一个单字节整型，表示压缩前的图片数据预处理方法。目前，只有过滤方法0(具有五种基本滤波器类型的自适应滤波)被定义。就像压缩方法字段一样，解码器也要检查过滤方法字段，如果是一个识别不出的码，就要报错。

交错方法是一个单字节整型，表示图片数据的传输顺序。目前定义了两个值，0(无交错)，1(Adam7 交错)

##### 4.1.2 PLTE调色板

PLET块包含1-256个调色板条目，每个都是三字节序列格式：

```
Red:   1 byte (0 = black, 255 = red)
Green: 1 byte (0 = black, 255 = green)
Blue:  1 byte (0 = black, 255 = blue)
```

条目的数量是由块长度决定的。一个块的长度如果不能被3整除是错误的。

这个块出现时，颜色类型(color type)必须是3，2或6。当颜色类型是0和4时(灰度图)，这个块不会出现。 如果这个块出现，必须要在IDAT块之前，且只能有一个块名为PLTE。

对于颜色类型3(索引颜色)，PLTE块是**必须的**。(此时像素值代表了调色板的索引)，PLTE中第一个条目由像素值0引用，第二个由像素值1引用，等等。调色板条目的数量不能超过目前图片的位深，(因为这样就索引不到了)，如4位位深$2^4=16$就是最大值。少于位深数量的是没问题的，但是如果像素值超过了PLTE条目的索引范围就会是错误的。

对于颜色类型2和6(真彩和带透明度真彩色)，PLTE块是**可选的**。如果存在，当查看器无法直接显示truecolor时，调色板将提供一组truecolor图像可以量化的1到256建议色。如果PLTE不存在，这样的查看器将需要自己选择颜色，但通常最好由编码器执行一次。？

##### 4.1.3 IDAT 图片数据

IDAT块包含实际的图片数据，数据的创建过程

* IHDR块中的长宽，颜色类型和位深，定义了原始数据的布局和总大小
* 根据IHDR块中过滤方法(目前只定义了0)过滤图片数据。每行需要附加一个过滤类型
* 使用IHDR块中定义的压缩方法压缩过滤后的数据

IDAT块包含了压缩算法的输出数据流。

读取过程则是上面的逆过程

IDAT块是可以有多个的，如果出现多个，这些块必须连续出现，中间没有其他块。压缩数据流是所有IDAT块串联的内容。编码器可以将压缩的数据流分割到IDAT块中。(允许多个IDAT块为了方便编码器可以使用固定内存工作。往往块大小对应编码器的buff大小)。IDAT块没有语义标记边界，可以发生在压缩数据流的任何地方。一个PNG文件里的每个IDAT块包含一个字节是合法的，尽管非常浪费空间。(而且，0长度的IDAT块也是合法的)

##### 4.1.4 IEND 图片尾部

IEND块最后出现，它标记了PNG数据流的尾部，块数据为空

#### 4.2 辅助块

所有辅助块都是可选的，在这个意义上，编码器没必要写这些块，解码器也可以忽略它们。但是当信息是可以获取到时编码器最好将它们写进标准辅助块。解码器也应该在合适的时机尽可能的读取这些块。

标准辅助块接下来按照字母排序列出来。png文件里的这些块出现的顺序不需要按此排序

##### 4.2.1 bKGD 背景颜色

bKGD块指定了默认的背景颜色。查看器不一定要接受这个块，查看器可以选择自己的背景色。

颜色类型3(索引色时)，bKGD包含的是调色板索引

```
 Palette index:  1 byte
```

值为背景色在调色板的中的索引，



对于颜色类型0和4(灰度，带透明度灰度)

bKGD包含

```
Gray:  2 bytes, range 0 .. (2^bitdepth)-1
```

为了一致性，不管位深是多少，都使用2字节的数据代表灰度等级



对于颜色类型2和6(真彩色，带透明度真彩色)

bKGD包含

```
Red:   2 bytes, range 0 .. (2^bitdepth)-1
Green: 2 bytes, range 0 .. (2^bitdepth)-1
Blue:  2 bytes, range 0 .. (2^bitdepth)-1
```

为了一致性，不管图像位深是多少都使用2字节代表背景色。

当出现bKGD块时，该块需要在IDAT块之前，且紧跟在PLTE块后。

##### 4.2.2 cHRM  主色品(色调饱和度)和白点

应用如果需要在PNG文件里指定与硬件设备无关的颜色可以使用cHRM块去指定1931照明协会(CIE)，红绿蓝主色的xy色度值，和参考白点

cHRM块包含

```
White Point x: 4 bytes
White Point y: 4 bytes
Red x:         4 bytes
Red y:         4 bytes
Green x:       4 bytes
Green y:       4 bytes
Blue x:        4 bytes
Blue y:        4 bytes
```

每个值都是4字节无符号整型。使用对应的x，y值乘以100000存储。例如，值为0.3127会被存储为31270。

cHRM在所有的PNG文件都可以出现。尽管在灰度图上没什么意义。

如果编码器不了解色品值的概念，就不应该写入cHRM块。如果没有cHRM块意味着图片的主色与依赖于设备。

如果该块出现，需要放在IDAT之前，且必须在PLTE之前

##### 4.2.3 gAMA 图片gamma值

gAMA块是指定产出图片的摄像机伽马值。从而指定相对于原场景的gamma值。更精确的说，gAMA块编码了文件的gamma值。

gAMA块包含

```
Image gamma: 4 bytes
```

这个值是编码成4字节无符号整型，代表的是实际gamma值的100000倍。如0.45的gamma值会被存储为45000

如果编码器不了解gamma值，就不要写入gAMA块。不出现gAMA块意味着gamma值是未知的。

如果gAMA块出现，需要在IDAT块之前，且在PLTE块之前。

##### 4.2.4 hIST 图片直方图

hIST块给出了调色板每个颜色的大概使用频率。一个直方图块只有在调色块(PLTE)出现后才会有。如果查看器在调色板中不能提供所有可使用的颜色，直方图也许会帮助它决定如何选择一个调色板颜色集。

hIST块包含一系列2字节无符号整型。每个PLTE块的条目hIST块中都有一个条目对应。hIST条目与图片中的像素里有该条目对应索引的数量成比例。具体的放大系数是由编码器决定的。

直方图条目是一个近似的。条目值为0则说明了对应的调色板条目在图片中根本没用到。如果某个颜色的像素数不为0则直方图该条目也不为0

当一个调色板图转成真彩图，直方图就变成近似值，因为解码器可能将像素映射到不同的调色板条目。这种情况下，0条目不应该出现。

hIST块，如果出现必须跟在PLTE块后面，在IDAT块之前。

##### 4.2.5 pHYs 物理像素维度

pHYs块指定了预期的像素大小和显示的纵横比。包含

```
Pixels per unit, X axis: 4 bytes (unsigned integer)
Pixels per unit, Y axis: 4 bytes (unsigned integer)
Unit specifier:          1 byte
```

Unit specifier值为0，那么pHYs块仅定义纵横比，像素的实际尺寸是没有定义的

```
0: unit is unknown
1: unit is the meter
```

转换提示：1英尺=0.0254米

如果这个块没出现，像素被认为是正方形。像素的物理大小是未知的。

如果出现需要放在IDAT块之前

##### 4.2.6 sBIT 重要位

为了简化解码，PNG指定只有几个确定的位深被使用。采样的可能值也要缩放到对应范围。但是sBIT块可以存储原始有效位。这允许解码器在数据位深不被PNG支持时无损恢复原始数据。我们推荐编码器新建一个sBIT块，如果转化自一个低采样位深。

对于颜色类型0(灰度)，sBIT块包含一个单字节，表明源数据有效位数。

颜色类型2(真彩)，sBIT块包含3个字节，分别是源数据红绿蓝通道的有效位数

颜色类型3(索引色)，sBIT块包含3个字节，分别表示调色板条目的红色、绿色和蓝色在源数据中的有效位数

颜色类型4(带透明度灰度图)，sBIT块包含2个字节，分别表示灰度和透明度数据的有效位数

颜色类型6(带透明度真彩)，sBIT块包含4个字节，分别表示红，绿，蓝和透明度数据的有效位数

该值需要大于0小于等于采样位深。(索引色则最大为8，其他类型的最大值是IHDR中定义的bit depth)

解码器不需要关注 sBIT：存储的图像是IHDR中定义的取样深度的有效PNG图片。但是如果解码器想要恢复原始精度的数据，可以通过右移取样数据。编码器必须以高阶位与原始数据匹配的方式缩放数据。

如果sBIT数据出现，必须在IDAT前，也必须在PLTE块前。

##### 4.2.7 tEXt 文本数据

编码器想要记录的文本信息可以存储在tEXt块。每个tEXt块包含一个key和文本格式为

```
Keyword:        1-79 bytes (character string)
Null separator: 1 byte
Text:           n bytes (character string)
```

keyword和文本是被一个0字节(空字符)分隔开的。keyword和text不可以包含空字符。Text不是以空字符结尾的(块长度可以用来定位结尾。keyword必须至少有一个字符，且小于80个字符。text可以是0到(块长度减去keyword和分隔符长度)允许的任意长度

tEXt块可以出现多个。

keyword代表text信息的含义。下面是一些常用的keywords

```
Title            Short (one line) title or caption for image
Author           Name of image's creator
Description      Description of image (possibly long)
Copyright        Copyright notice
Creation Time    Time of original image creation
Software         Software used to create the image
Disclaimer       Legal disclaimer
Warning          Warning of nature of content
Source           Device used to create the image
Comment          Miscellaneous comment; conversion fromGIF comment
```

对于创建日期的关键词，格式定义在 RFC 1123的 5.2.14。解码器应该允许其他的格式

为了不同的目的其他的关键词也可以使用。关键字可以向PNG规范的维护者注册。未被注册的私有的关键字也可以使用。自定义的关键字应该是合理的自解释的，以便最大限度地减少同一关键字被不同的人用于不同定义的可能性。

keyword和text字符都是 ISO 8859-1 (Latin-1)里的字符集[ISO-8859]。text里如果要换行使用换行符(数字10)。而text里使用其他的控制字符是不鼓励的。



keywords必须仅包含Latin-1中的字符。只有字符码32-126和161-255的十进制值是允许的。为了防止keyword的误读，首尾空格和连续空格是被禁止的。注意非换行空格(160) 也是不被允许的，因为它和普通空格看起来无法分辨。

keywords的拼写必须要和登记的完全相同，以便解码器可以通过简单地文本对比找到特定关键词。所以关键词也被认为是大小写敏感的。

##### 4.2.8 tIME 图片上次更新时间

tIME块给出上次图片更新的时间，不是图片创建的时间。包含

```
Year:   2 bytes (complete; for example, 1995, not 95)
Month:  1 byte (1-12)
Day:    1 byte (1-31)
Hour:   1 byte (0-23)
Minute: 1 byte (0-59)
Second: 1 byte (0-60)    (yes, 60, for leap seconds; not 61,
                                      a common error)
```

指定的是世界时，Universal Time(UTC，也叫GMT) 而不是本地时间。

tIME块的目的是在图片发生变化的时候自动更新时间戳。而不推荐PNG的编辑者改变这个块。

##### 4.2.9 tRNS 透明度

tRNS块指定了图片简单透明度，不管是调色板调色板索引，还是单个采样，都有透明度指定对应值。尽管简单透明度没有全通道透明度那么优雅，但是它使用了更少的空间。

对于颜色类型3(索引色)，tRNS块包含一系列一个字节的透明度值，对应PLTE块里的条目，

```
Alpha for palette index 0:  1 byte
Alpha for palette index 1:  1 byte
... etc ...
```

每条都表示调色板中的颜色的对应透明度。有着对应于8位全彩透明通道相同的解释。0时全透明，255是全不透明度，与图片的位深无关。tRNS块可以只包含调色板条目中一部分索引的透明度。这种情况下，剩下的条目透明度被认为是255。通常情况下，只有index0是透明的，tRNS块只有1字节。

颜色类型0(灰度)，tRNS包含一个单一的灰度等级，格式

```
Gray:  2 bytes, range 0 .. (2^bitdepth)-1
```

为了一致性，2字节是图片位深。对应的灰度等级被认为是全透明，其他的像素是全不透明。

颜色类型2(真彩)，tRNS块包含一个RGB颜色值，格式

```
Red:   2 bytes, range 0 .. (2^bitdepth)-1
Green: 2 bytes, range 0 .. (2^bitdepth)-1
Blue:  2 bytes, range 0 .. (2^bitdepth)-1
```

为了一致性，2字节是图片位深。对应的颜色被认为是透明的，其他的像素是全不透明。

颜色类型(4,6)是被禁止的，因为4，6类型里已经有透明度了。

注意：当处理16位灰度或真彩数据，需要比较采样数据来决定像素是否是透明的。尽管显示解码器有可能丢弃低字节，这个操作应该在比较之前。例如，一个灰度等级 0x0001是透明的，如果只比较高字节，那么0x0002也被认为是透明的了，这样是不对的。

如果有tRNS块，那么应该出现在IDAT块前。在PLTE块后。

##### 4.2.10 zTXt 压缩文本

ZTXt块包含文本数据，和tEXt一样。但是zTXt有压缩的优势。zTXt和tEXt语义上是一样的，但是zTXt适合存储大量文本。

一个zTXt块包含：

```
Keyword:            1-79 bytes (character string)
Null separator:     1 byte
Compression method: 1 byte
Compressed text:    n bytes
```

keyword和Null separator和tEXt一样。注意Keyword是没有压缩的。压缩方法使用Compression method 定义。

目前只有一个方法定义，0(deflate/inflate compression)。紧接着压缩方法字节后的是压缩的数据流来补足剩余块。使用压缩方法0，数据遵循zlib数据格式。

解压缩生成和tEXt等效的Latin-1文本。

任意数量的zTEt和tEXt块可以出现。

#### 4.3 标准块的总结

这个表总结了标准块类型的一些属性

重要块：

```
Name  Multiple  Ordering constraints
                         OK?

IHDR    No      Must be first
PLTE    No      Before IDAT
IDAT    Yes     Multiple IDATs must be consecutive
IEND    No      Must be last
```

辅助块：

```
Name  Multiple  Ordering constraints
                         OK?

cHRM    No      Before PLTE and IDAT
gAMA    No      Before PLTE and IDAT
sBIT    No      Before PLTE and IDAT
bKGD    No      After PLTE; before IDAT
hIST    No      After PLTE; before IDAT
tRNS    No      After PLTE; before IDAT
pHYs    No      Before IDAT
tIME    No      None
tEXt    Yes     None
zTXt    Yes     None
```

tEXt和zTXt块的keyword定义

```
         Title            Short (one line) title or caption for image
         Author           Name of image's creator
         Description      Description of image (possibly long)
         Copyright        Copyright notice
         Creation Time    Time of original image creation
         Software         Software used to create the image
         Disclaimer       Legal disclaimer
         Warning          Warning of nature of content
         Source           Device used to create the image
         Comment          Miscellaneous comment; conversion from
                          GIF comment
```

#### 4.4 附加块类型

PNG-EXTENSIONS 里定义了其他的块，应用没有之前的块广泛。但是应用作者可以在合适的情况下使用该块。

### 5 Deflate/Inflate 压缩

PNG压缩方法0，(也是PNG定义的唯一压缩方法)。指定了32k内的deflate/inflate压缩。Deflate 压缩是一个LZ77

的衍生用法，用在zip，gzip，pkzip和相关程序中。专利免费。

Png的Deflate-compressed数据流，是存储为"zlib"格式的，格式为

```
Compression method/flags code: 1 byte     
Additional flags/check bits:   1 byte
Compressed data blocks:        n bytes
Check value:                   4 bytes
```

zlib格式规范在[RFC-1950]。压缩过的zlib数据可以以任一方式分割到不同IDAT块里

1字节的Compression method/flags code，

* 0-3 位是CM     Compression method 必须是8
* 4-7位是 CINFO  Compression info    可以是0-7代表 0-32k的LZ77窗。

1字节的Additional flags/check bits:

* 0-4 位是 FCHECK  (check bits for CMF and FLG)
* 第5位是  FDICT   (preset dictionary)预设字典，PNG里必须是0
* 6-7位是 FLEVEL   (compression level) 压缩等级

```
 +---+---+
 |CMF|FLG| (2 bytes - Defines the compression mode - More details below)
 +---+---+
 +---+---+---+---+
 |     DICTID    | (4 bytes. Present only when FLG.FDICT is set.) - Mostly not set
 +---+---+---+---+
 +=====================+
 |...compressed data...| (variable size of data)
 +=====================+
 +---+---+---+---+
 |     ADLER32   |  (4 bytes of checksum)
 +---+---+---+---+
```

压缩zlib数据流被存储在一系列块，每一个可以代表原始(未压缩的)数据，LZ77-压缩的数据编码成Huffman编码。

一个标记位放到最后标记最后一个块，用于解码器识别压缩数据流的结尾。更多的压缩算法和解码算法在deflate规范里 [RFC-1951].

check value存储在zlib数据流的最后，值是根据未压缩的数据计算得到的。和CRC的算法不一样。zlib check value是主要用于交叉核对(cross-check )压缩和解压缩的算法是不是正确实现了。验证区块CRCs可以确保PNG文件被完整传输。

在PNG文件中，所有IDAT块内容的串联构成了如上所述的zlib数据流。此数据流解压缩为过滤后的图像数据，如本文档其他部分所述。

需要强调的是IDAT块间的边界是任意的，可以在zlib数据流的任一部分。IDAT块边界和deflate块边界或zlib数据的任何其他特征之间不一定存在任何相关性。例如，终止zlib的Check value完全可以跨IDAT块分割。

类似的，图片数据结构(行边界)与压缩块边界或IDAT块边界也没有必要的关联性。完整的图片数据是被一个zlib数据流表示的。zlib数据流又是被多个IDAT块存储的。当然，某些编码器可能根据文件结构进行编码。但解码器不能依赖于此。

PNG中的zTXt块也使用了zlib数据流。在zTXt块， compression method byte字段后的Compressed text就是上面说的zlib流。Compressed text会被解压缩成用户可读的文本，含义为块中的keyword字段。zTXt中的数据不像图片数据可以分割成不同的IDAT块，每个zTXt块都包含的独立的zlib数据。

压缩和解压的附加文档和c算法类在  <URL:ftp://ftp.uu.net/pub/archiving/zip/>.

### 6. 过滤算法

这章描述压缩前的过滤算法，目的是转换图片数据为了更好地压缩大小。

#### 6.1 过滤类型

PNG过滤方法0定义了5中基本过滤类型

```
Type    Name

0       None
1       Sub
2       Up
3       Average
4       Paeth
```

注意，IHDR中的过滤方法0正好指定了这组五种过滤类型。如果过滤类型集曾经被扩展，则会为扩展集分配一个不同的过滤器方法编号(比如到6)，以便解码器无需解压缩数据以发现其包含不受支持的过滤器类型。

编码器可以选择图片每行使用哪种过滤方法。在压缩之前，每行之前有一个filter type byte字段，指定了每行使用的过滤算法。

过滤算法粒度是字节，不是像素，不管图片的颜色类型和位深是什么样的。如果包含透明度，那么透明度通道也是用相同的方式过滤。

当图片是交错类型时，每次传输(总共7次)都被认为是独立的图像。每次传输的像素形成的字节会被过滤，"前一行"不是整张图像的相邻行，而是这次传输的前一行。每次传输都是长方形的图像，且小于完整图像大小，当某次传输为空时，不应用过滤。

对于所有的过滤，行的第一个像素被当做0，对于参考前一行的过滤，第一行被认为是0。

要反转过滤的效果，解码器必须使用同一行上前一个像素的解码值，前一行里当前像素正上方的像素。当前像素左上方的像素。这意味着至少一行的图片数据自始至终需要被解码器存储。尽管一些过滤类型不参考前一行，解码器解码时仍需要存储每一行，因为下一行的反转滤波也许依赖本行。

PNG对使用何种滤波类型不施加任何限制。但是，过滤并非对所有类型的数据都同样有效。

#### 6.2 过滤类型 0：None(无过滤)

None滤波类型，每行不需要更新，只要在数据前面插入一个过滤类型。

#### 6.3 过滤类型1：Sub

减过滤传输字节和它前一像素的差值。计算方式

$Sub(x) = Raw(x) - Raw(x-bpp)$

x范围是[0，行字节数量-1]， Raw(x)表示本行第x个字节数据，bpp是一个完整像素占用的字节数，向上取整。例如，颜色类型2，位深为16，bpp就等于6(三次采样，3*16/8=6)，颜色类型0，位深为2，bpp就等于1，颜色类型4，位深为16，bpp就等于4(2字节灰度，2字节透明通道)。

注意，计算是以字节为单位，不是位深。一个16位深的图片，不管大端小端，都是高字节对应高字节，低字节对应低字节，因为bpp是定义好的。

无符号的对256取模算法被使用，所以取值结果1字节放得下

对于x<0的情况，假设Raw(x)=0,

反转过滤效果使用公式

$Sub(x) + Raw(x-bpp)$

(结果如果大于256则对256取模。即2进制相加时舍弃第8位的进位。)

Raw的数据依赖于前一个已经解码的字节。

#### 6.4 过滤类型2：Up

Up过滤，和Sub过滤相似，不过是使用上方的像素代替左边。公式

$Up(x) = Raw(x) - Prior(x)$

x范围从[0，行字节数量-1]， Raw(x)表示本行第x个字节数据， Prior(x)前一行的未过滤字节。

注意，计算是以字节为单位，不是位深。

无符号的对256取模算法被使用，所以取值结果1字节放得下。结果值作为过滤后的行被传输

图片(交错模式为一次传输的图片)的第一行，设定 Prior(x) = 0。

反转过滤效果使用公式：

$  Up(x) + Prior(x)$

(结果如果大于256则对256取模)。prior(x)数据依赖前一行已经解码的字节数据

#### 6.5 过滤类型3：Average

Average过滤使用两个相邻像素(左边和上边)的平均值计算像素的值。公式

$Average(x) = Raw(x)-floor((Raw(x-bpp)+Prior(x))/2)$

x范围从[0，行字节数量-1]， Raw(x)表示本行第x个字节数据， Prior(x)前一行的未过滤字节。bpp是一个完整像素占用的字节数，向上取整

结果值作为过滤后的行被传输

无符号的对256取模算法被使用，所以最终结果1字节放得下。但是中间过程的$Raw(x-bpp)+Prior(x)$需要使用9位保证不溢出。 floor函数为向下取整，也就是最终结果的二进制数右移一位。

对于x<0的情况，假设Raw(x)=0,图片(交错模式为一次传输的图片)的第一行，假设 Prior(x) = 0。

反转过滤效果使用公式：

$Average(x) +floor((Raw(x-bpp)+Prior(x))/2)$

(结果如果大于256则对256取模)。Raw的数据依赖于前一个已经解码的字节。prior(x)数据依赖前一行已经解码的字节数据

#### 6.6 过滤类型4：Paeth

Paeth过滤是一个三个邻接像素(左，上，左上)的一次方程，公式为

$Paeth(x) = Raw(x) - PaethPredictor(Raw(x-bpp), Prior(x), Prior(x-bpp))$

x范围从[0，行字节数量-1]，Raw(x)表示本行第x个字节数据， Prior(x)前一行的未过滤字节。bpp是Sub过滤类型中定义的。

无符号的对256取模算法被使用，所以最终结果1字节放得下。结果值作为过滤后的行被传输

PaethPredictor函数定义伪代码如下：

```
PaethPredictor (a, b, c)
begin
 a = left, b = above, c = upper left
 p := a + b - c        ; initial estimate
 pa := abs(p - a)      ; distances to a, b, c
 pb := abs(p - b)
 pc := abs(p - c)
 return nearest of a,b,c,
 breaking ties in order a,b,c.
 if pa <= pb AND pa <= pc then return a
 else if pb <= pc then return b
 else return c
end
```

PaethPredictor函数必须精确计算，对256取模的步骤仅在最后减法的那一步使用。

a,b,c的顺序也是固定的，左，上，左上。

对于x<0的情况，假设Raw(x)=0 且 Prior(x) = 0，图片(交错模式为一次传输的图片)的第一行，假设 Prior(x) = 0。

反转过滤效果使用公式：

$Paeth(x) + PaethPredictor(Raw(x-bpp), Prior(x), Prior(x-bpp))$

(结果如果大于256则对256取模)。Raw的数据依赖于前一个已经解码的字节。prior(x)数据依赖前一行已经解码的字节数据。PaethPredictor 的函数逻辑在编码和解码时相同。

### 7. 块顺序规则

为了允许新的块类型加进PNG，需要建立一个块类型顺序的规则。否则PNG的编辑程序遇到识别不出的块不知道如何处理。

我们定义一个"PNG编辑器"是一个可以更新PNG文件且最大化保存辅助块信息的程序。给出两个例子，一个是添加或更新text块，一个是为真彩PNG文件添加一个调色板。在这个意义上，普通的图片编辑器不是PNG编辑器，因为普通的图片编辑器通常丢弃所有未识别的信息。(我们强烈建议在处理PNG文件时保留辅助信息)。

一个可能的问题是，假如一个可安全拷贝的辅助块需要出现在PLTE块之后，如果我们程序添加PLTE块时没有识别这个辅助块，那么插入PLTE块可能会插入到辅助块之后。我们可以通过丢弃所有未识别的块来避免这种情况，但是这种方式不太好。所以PNG辅助块没有顺序限制。

为了在允许将来扩展的同时防止这种类型的问题，我们对PNG编辑器的行为和允许的块排序要求都施加了一些约束。

#### 7.1. PNG编辑器行为

规则：

* 当拷贝一个未知的不安全拷贝辅助块，PNG编辑器不能改变其与重要块的相对顺序。可以在一对重要块之前随意更改与其他辅助块的相对位置。
* 拷贝一个未知的安全拷贝快，不应该改变其和IDAT块的前后顺序。
* 当拷贝一个已知的辅助块类型，编辑器只需遵守该块类型的特定块排序规则。也可以选择应用上述一般规则。
* PNG编辑器遇到一个未知的重要块类型应该放弃读取，因为无法确定修改包含此类块的文件是否会产生有效文件。

#### 7.2 辅助块的顺序

辅助块顺序的规则

* 不安全拷贝块可能和重要块有顺序要求
* 安全拷贝块可能和IDAT块有顺序要求

实际上辅助块类型的顺序没有这么严格。

解码器对任何辅助块的顺序的假设不得超过块排序规则规定的范围。更不能假定某些辅助块与其他辅助块位置相关。

#### 7.3 重要块的顺序

### 8. 其他问题

#### 8.1 文件扩展名

".png"

#### 8.2 互联网媒体类型

[RFC-2045, RFC-2048]  "image/png"   "image/x-png" 

#### 8.4 存储多张png格式

一张PNG存储多张PNG(GIF转过来的)，

#### 8.5 安全考虑

PNG文件是由块集合组成。块有可能包含恶意代码，但是目前没有发现在解码PNG可以被执行的代码风险。

现在还不确定未来是否会出现有风险的块。当一个块被注册为公共块时会考虑安全问题。未知块也不会有风险因为会被忽略，最多被拷贝到另一个PNG文件。

tEXt和zTXt包含要显示为纯文本的数据。有可能解码器在显示这些文本时没有过滤控制字符如(ESC)，系统就可能就会出现不安全的行为。我们推荐解码器滤除控制字符以避免这些风险。

因为每个块的长度是可以在开始获取的，每个块尾部也有的CRC，所以对毁坏的数据和想要溢出解码器缓存的欺骗块有很强的防御。此外，PNG签名字节提供了常见文件传输错误的早期检测。

数据损坏会导致CRC验证错误，这种损坏的唯一可能后果是图像中的像素显示不正确。如果未检查IHDR块的CRC，并且宽度或高度字段已损坏，则可能会发生更糟糕的情况。

不好的解码器会被缓存溢出影响，因为块可能会非常大，最大$2^{31}-1$个字节，但是恰当书写的解码器可以不费力的处理大块数据。

### 9. 编码建议

这章给出一些编码行为的建议。PNG编码的唯一要求就是按照先前的章节生成符合格式的文件。但是，使用下面的建议可以得到更好的结果。

#### 9.1 取样深度缩放

当输入的采样深度不是PNG可以直接使用的，编码器需要将深度对应缩放到PNG允许的几个位深。最精确的缩放是使用线性等式

```
 output = ROUND(input * MAXOUTSAMPLE / MAXINSAMPLE)
```

MAXINSAMPLE是输入采样的取值范围 0-MAXINSAMPLE，

MAXOUTSAMPLE是转换后的PNG可以使用的位深代表的最大值 ($2^{sampledepth} -1$)

如 0-512 表示的值要变成 0-255那么就要  值*255/512

一个近似的线性缩放方法可以使用"left bit replication" 左边位复制机制。它将原有效位移依次左移到最高有效位，并从最高有效位复制填充到剩余的位。

比如5位的取样要被放大到8位，如果取样值是27 ，那么原比特位值为

```
4 3 2 1 0
---------
1 1 0 1 1
```

左边位复制到8位

```
         7 6 5 4 3  2 1 0
         ----------------
         1 1 0 1 1  1 1 0
         |=======|  |===|
             |      Leftmost Bits Repeated to Fill Open Bits
             |
         Original Bits
```

这个结果匹配线性缩放等式，左位复制通常提供与线性缩放相同的值，(误差不超过1？)

一个不太精确地近似是简单的左移原有效位，低位填充0。这个方案不能很好的对应白色，因为不会生成全1的的最大值。最后会使图片效果稍微变暗。通常不推荐这个方法。但是这个这种方法可以改善压缩效果，特别是大于8位取样位深的时候。知道这些利弊后，由于零填充缩放引入的相对误差在高采样深度时很小，一些编码器可能会选择使用它。0填充不能用在透明通道的数据，但是，因此许多解码器都会使用全零和全一的alpha值。

当解码器写入了一个sBIT块，缩放时需要保证存储的高位与原始数据一致。就是，如果sBIT块指定了一个采样深度S，那么高阶S位存储的数据必须和原始数据的S位数据一致。这允许解码器通过右移恢复原始数据。添加的低阶位不受约束。请注意，上述所有缩放方法都满足此限制。

当放大原始数据时，低位填充的方式应该一致，就是，相同的原数据应该会生成相同的采样数据。这样可以通过减少不同值的数量来改进压缩。但是，这不是必须的，一些编码器也许不会遵循这个。例如，编码器可能会对低阶位进行抖动，以提高文件大小为代价来改善显示的图像质量。

在一些应用里，原始数据的值范围不是2的整数次幂。线性缩放依然可以用，但是移位方法不行。推荐方式是，如果原数据值范围是$[0,2^S-1]$，那么写入S到sBIT块，如果不是2的整数次幂就不用写入该块

#### 9.2 编码gamma

在编码器里合适的处理gamma编码和gAMA块依赖于采样值的历史记录以及这些值是否已量化为整数。

如果编码器可以访问浮点或高精度整数形式的采样强度值（可能来自计算机图像渲染器），则建议编码器在将数据量化为整数值以存储在文件中之前执行自己的gamma编码。在此阶段应用gamma编码会在给定采样深度下产生较少带状伪影的图像，或者在保持相同视觉质量的同时允许更小的采样。

一个线性亮度等级，0-1的浮点数可以被转化成gamma编码的采样值

$ sample = ROUND((intensity ^ {encoder\_gamma}) * MAXSAMPLE)$

如果file_gamma 值被写到gAMA块，即encoder_gamma。那我们假设初始亮度值为线性(实际上，摄影机的gamma为1.0)

如果仅将图像写入文件，则encoder_gamma可以任意选择。值0.45或0.5通常是不错的选择，因为它们在视频系统中很常见，因此大多数PNG解码器应该能够很好地显示这些图像。

一些图像渲染器可能同时将图像写入PNG文件并在屏幕上显示。显示的像素应根据使用中的显示系统和查看条件进行伽马校正，以便用户看到预期场景的正确表示。需要一个合适的伽马校正值，计算方式

```
screen_gc = viewing_gamma / display_gamma
```

如果渲染器希望将相同的gamma校正采样值写入PNG文件，从而避免文件输出时单独编码gamma步骤，则此screen_gc值应写入gAMA块中。这将允许PNG解码器再现文件的创建者在屏幕上看到的内容（前提是解码器正确支持gAMA块中的任意值）。

然而，渲染器使用适合于观看条件的伽马对屏幕显示应用伽马校正，并且使用伽马的标准值（例如0.5）对用于文件存储的样本值单独进行伽马编码，这同样合理。事实上，这是最好的，因为一些PNG解码器可能无法准确显示具有异常gAMA值的图像。

计算机图形渲染器通常不执行gamma编码，而是使采样值与场景灯光强度成正比。如果PNG编码器接收到已量化为线性光整数值的样本值，则对其进行gamma编码没有意义，且只会导致更多信息的丢失。编码器应该只将样本值写入PNG文件。此线性光强样本编码相当于gamma为1.0的gamma编码，因此生成线性样本的图形程序应始终新建一个指定gamma为1.0的gamma块。

当采样值直接从一部分硬件得到的，gAMA的校正值就由硬件的特性得出。对于视频数字化仪（“帧抓取器”），NTSC的gAMA应为0.45或0.5（PAL或SECAM可能更小），因为摄像机传输功能是标准化的。图像扫描仪的gamma不好预测。









### 13.附录：Gamma教程

如果成像系统的所有组件都是线性的，那么图形编程人员将很方便。来自电子相机的电压将与场景中光的强度（功率）成正比，CRT发出的光将与其输入电压成正比，依此类推。然而，现实世界中的设备并非如此。所有的CRT显示器、几乎所有的照相胶片和许多电子相机都具有非线性信号-光强度或强度-信号特性。

幸运的是，所有这些非线性器件都有一个传递函数，它可以很好地近似于一种数学函数：幂函数。该幂函数具有一般方程



$ output = input ^ {gamma}$

"gamma"通常使用希腊字母γ，是指数。

按照惯例，“输入”和“输出”都被缩放到范围0..1，0表示黑色，1表示最大白色（或红色等）。归一化后，幂函数就完全由指数"gamma"值描述

因此，给定一个特定的设备，我们可以测量它的输入输出函数，将幂函数拟合到这个测量的传递函数，提取指数，并称之为gamma。我们经常说"这台设备的gamma值是2.5"就是说"这台设备的幂函数指数是2.5"。我们还讨论数学变换的gamma，或者帧缓冲区中查找表的gamma，只要输入和输出由上面的幂律表达式关联。

#### gamma的组合

真正的成像系统将有几个组件，其中不止一个是非线性的。如果所有部件的传递特性都是幂函数，则整个系统的传递函数也是幂函数。整个系统传递函数的指数（gamma）就是系统中各个阶段的所有单个指数（gamma）的乘积。

此外，线性也没有问题，因为指数为1.0的幂函数实际上是线性函数。所以线性传递函数只是幂函数的一个特例，伽马值为1.0。

因此，只要我们的成像系统只包含具有线性和幂律传递函数的级，我们就可以有意义地讨论整个系统的伽马。大多数真实的成像系统确实如此。

#### 总gamma应该是多少？

如果成像系统的总伽马值为1.0，则其输出与输入成线性比例。这意味着再现图像中任意两个区域的强度比将与原始场景中的强度比相同。这似乎应该始终是成像系统的目标：精确地再现原始场景的色调。唉，事实并非如此。

当在“明亮”的条件下观看再现的图像时，房间附近的其他白色物体的亮度与图像中的白色物体的亮度大致相同，那么总伽马值为1.0确实可以真实再现自然场景。在室内灯光下观看的照片和在明亮室内灯光下观看的计算机显示器是典型的“明亮环绕”观看条件。

然而，有时图像旨在在“黑暗环绕”条件下观看，其中除图像外，房间基本上为黑色。如通过投影观看电影和幻灯片（透明胶片）。在这种情况下，对原始场景的准确再现会产生一幅人类观众认为“平”且缺乏对比度的图像。事实证明，投影图像需要有一个相对于原始场景约1.5的伽马值，以便观众判断它是否“自然”。因此，幻灯片的伽马值设计为约1.5，而不是1.0。

还有一种被称为“昏暗环绕”的中间状态，在这种状态下，观看者仍然可以看到房间的其余部分，但明显比再现的图像本身暗。这是典型的电视观看，至少在晚上，以及昏暗的电脑工作区。在昏暗的环境条件下，为了看起来自然，电子生成的图像需要相对于原始场景具有约1.25的伽马值。

在黑暗环境中对增强对比度（伽马）的要求是由于人类视觉系统的工作方式，同样适用于计算机监视器。因此，PNG查看器试图为其显示的图像实现最大真实感，实际上需要知道房间照明条件是什么，并相应地调整显示图像的伽马值。

如果向用户询问房间照明条件不合适或太困难，只需假设总伽马（如下定义）应为1.0或1.25。这就是大多数实现伽马校正的系统所做的。

#### 9.3 编码颜色

如果编码器可以确定源显示原色的色度，或者基于图像的原点或运行它的硬件进行强烈猜测，那么强烈建议编码器输出cHRM块。如果它这样做了，gAMA块也应该被写入；如果gAMA缺失，解码器对cHRM几乎无能为力。

使用最新视频设备创建的视频可能使用CCIR 709原色和D65白点[ITU-BT709]，它们是：

```
                  R           G           B         White
         x      0.640       0.300       0.150       0.3127
         y      0.330       0.600       0.060       0.3290
```

一个较老但仍然非常流行的视频标准是SMPTE-C[SMPTE-170M]：

```
                  R           G           B         White
         x      0.630       0.310       0.155       0.3127
         y      0.340       0.595       0.070       0.3290
```

最初的NTSC原色已经几十年没有使用了。尽管您仍然可以在标准文档中找到列出的NTSC编号，但您不会找到任何实际使用这些编号的图像。

生成PNG文件作为输出的扫描仪应将滤镜色度插入到cHRM块中，并将camera_gamma插入到gAMA块中。

对于手绘或数字编辑的图像，您必须确定在制作时在哪个监视器上查看它们。许多图像编辑程序允许您指定正在使用的监视器类型。这通常是因为它们在内部的某个设备独立空间中工作。这样的程序有足够的信息来编写有效的cHRM和gAMA块，并且应该自动这样做。

如果编码器编码是执行全光谱渲染的计算机图像渲染器的一部分，则用于从**内部设备独立颜色**空间转换为RGB的监视器值应写入cHRM块。任何位于所选RGB设备色域之外的颜色都应剪裁或以其他方式限制在色域之内；PNG不存储色域外的颜色。

如果计算机图像渲染器直接在**设备相关的RGB空间**中执行计算，则不应写入cHRM块，除非已将场景描述和渲染参数调整为在特定监视器上看起来良好。在这种情况下，应该使用该监视器的数据（如果已知）来构造cHRM块。

通常情况下，图像的确切来源是未知的，特别是如果它是以其他形式出现的。一些图像格式存储校准信息，可用于填充cHRM块。例如，所有PhotoCD图像都使用CCIR 709原色和D65白点，因此在转换PhotoCD文件时，可以将这些值写入cHRM块。PhotoCD还使用SMPTE-170M传递函数，该函数近似于0.5的gAMA。（PhotoCD可以存储RGB色域之外的颜色，因此在写入PNG格式之前，图像数据需要色域映射。）TIFF 6.0文件可以选择性地存储校准信息，如果存在校准信息，则应将其用于构造cHRM块。GIF和大多数其他格式不存储任何校准信息。

不建议文件格式转换器尝试将提供的图像转换为不同的RGB颜色空间。将数据存储在PNG文件中，不进行转换，并记录源原色（如果已知）。由于色域不匹配和舍入错误，在文件转换时进行颜色空间转换是个坏主意。与gamma转换一样，最好无损地存储数据，并且在最终显示图像时最多进行一次转换。

#### 9.4 透明通道创建

alpha通道可以被视为临时隐藏图像透明部分的遮罩，也可以被视为构建非矩形图像的手段。在**第一种**情况下，应保留完全透明像素的颜色值以备将来使用。在**第二种**情况下，透明像素不携带有用的数据，只是用来填充PNG所需的矩形图像区域。在这种情况下，应为所有完全透明的像素**分配相同的颜色值**，以获得最佳压缩效果。

图像作者应该记住，解码器可能会忽略透明度控制。因此，只要可行，分配给透明像素的颜色应该是合理的背景色。

对于不需要完整alpha通道或无法承受压缩效率成本的应用程序，也可以使用tRNS透明块。

如果图像具有已知的背景颜色，则该颜色应写入bKGD块中。即使忽略透明度的解码器也可能使用bKGD颜色填充未使用的屏幕区域。

如果原始图像具有premultiplied 预乘（也称为“associated 关联”）alpha数据，则将其转换为PNG的非预乘格式，方法是将每个采样值除以相应的alpha值，然后乘以图像位深度的最大值，并舍入为最接近的整数。在有效的预乘数据中，样本值永远不会超过其相应的alpha值，因此除法结果应始终在0到1的范围内。如果alpha值为零，则输出黑色（零）。

#### 9.5 建议的调色板块

PLTE块可以出现在真彩PNG文件中。在这些文件中，区块不是图像数据的重要部分，而只是表示一个建议的调色板，观众可以使用该调色板在索引彩色显示硬件上显示图像。在truecolor硬件上运行的查看器与建议的调色板无关。

如果编码器选择提供建议的调色板，建议还编写一个hIST块，以指示调色板条目的相对重要性。直方图值最容易计算为“最近邻”计数，即在未应用抖动的情况下每个调色板项的近似使用量。（由于开发了建议的调色板，这些计数通常是免费的。）

对于颜色类型2（不带alpha通道的truecolor）的图像，建议仅参考RGB数据计算调色板和直方图，忽略任何透明颜色规范。如果文件使用透明度（具有tRNS块），则查看者可以轻松地调整生成的调色板，以便与预期的背景色一起使用。他们只需将最接近tRNS颜色的调色板条目替换为其背景色（可能与文件的bKGD颜色匹配，也可能不匹配，如果有的话）

对于颜色类型为6（带alpha通道的truecolor）的图像，建议，1.使用bKGD块，2.参考图像计算调色板和直方图，就像在与指定背景色合成后显示的那样。此定义对于确保为具有很小alpha值的像素生成有用的调色板条目是必要的。生成的调色板可能仅对以相同背景颜色呈现图像的显示有用。如果PNG编辑器更改或删除颜色类型为6的图像中的bKGD块，建议它们删除或重新计算调色板。

如果PLTE在颜色类型为6的图像中出现时没有bKGD，则调色板的计算环境未指定。

#### 9.6 过滤选择

对于颜色类型为3（索引颜色）的图像，过滤器类型0（无）通常最有效。请注意，**256色或更少颜色**的彩色图像几乎应始终以**索引**颜色格式存储；truecolor格式可能要大得多。

对于位**深度小于8**的图像，也建议使用0型过滤器。对于低位深度的灰度图像，将图像扩展为8位表示并应用过滤可能是一个优化，但这不常见的。

对于**真彩色和灰度**图像，五种过滤器中的任何一种都可能被证明是最有效的。如果编码器使用固定滤波器，Paeth滤波器很可能是最好的。

为了获得最佳的真彩色和灰度图像压缩效果，我们推荐一种自适应滤波方法，其中为每个扫描线选择一个滤波器。以下简单的启发式算法在早期测试中表现良好：使用所有五个过滤器计算输出扫描线，并选择**输出绝对值之和最小**的过滤器。（将输出字节视为此测试的有符号差异。）这种方法通常优于任何单一的固定滤波器选择。然而，随着PNG获得更多经验，可能会发现更好的启发式方法。

根据这些建议进行过滤对隔行扫描图像和非隔行扫描图像都有效。

#### 9.7 文本块处理

必须为每个文本块提供非空关键字。如果没有更好的文本描述，可以使用通用关键字“Comment”。如果使用了用户提供的关键字，请确保它符合关键字限制。

PNG文本字符串应使用 Latin-1字符集。编码器应避免存储 Latin-1中未定义的字符，如果本地系统的字符集不是 Latin-1，则应提供字符代码重新映射。

编码器应阻止创建超过79个字符的单行文本，以便于阅读

建议使用未压缩的文本块输出大小小于1K（1024字节）的文本项。特别是，建议始终使用未压缩的文本块输出基本标题和作者关键字。另一方面，冗长的免责声明是zTXt的理想选择。

在某些情况下，将tEXt和zTXt块放在图像数据之后（IDAT之后）可以加快图像显示速度(流式读取)，因为解码器不必通过读取文本来获取图像数据。但建议在IDAT之前显示小文本块，如图像标题。

#### 9.8 私有块的使用

应用程序可以使用PNG私有块来携带其他应用程序不需要理解的信息。这些块必须用第二个字母小写命名，以确保它们永远不会与任何未来的公共块定义冲突。但是，请注意，不能保证其他应用程序不会使用相同的私有块名称。如果使用私有块类型，则在块数据的开头存储额外的标识信息是明智的(用来确定是自己定义的私有块)。

对于存储信息的所有私有块，使用辅助块类型（小写首字母），而不是关键块类型，这些信息对于查看图像来说不是绝对必要的。不鼓励创建私有重要块，因为它们会使PNG文件不可移植。此类块不应用于公开可用的软件或文件中。如果私有关键块对于您的应用程序至关重要，建议在文件开头附近显示一个，这样标准解码器在发现无法处理文件之前就不需要读太远。如果您希望组织外的其他人了解您发明的块类型，请联系PNG规范的维护者，提交一个建议的块名称和定义，以添加到专用公共块列表中。请注意，在注册获得批准之前，不得在公开可用的软件或文件中使用建议的公共区块名称（第二个字母大写）。

如果辅助块包含人类用户可能感兴趣的文本信息，则不应为其创建特殊的块类型。而是使用tEXt块并定义合适的关键字。这样，不使用您的软件的用户就可以使用这些信息。

tEXt块中的关键字应该是合理的自解释的，因为这样做的目的是让其他用户知道tEXt块包含什么。如果有一般用途，可以向PNG规范的维护者注册新关键字。但是，允许使用关键字而不首先注册它们。

#### 9.9 私有类型和方法代码

本规范仅定义某些字段的某些可能值的含义。例如，仅定义了压缩方法0和过滤器类型0到4。在为这些字段中的任何字段创建实验性或私有值定义时，必须使用大于127的数字。128以下的数字保留用于本规范未来可能的公共扩展。请注意，使用私有类型代码可能会使标准解码器无法读取文件。除非出于实验目的，否则强烈反对使用此类代码，并且不应出现在公开可用的软件或文件中

#### 10. 解码器建议

本章给出了一些关于解码器行为的建议。PNG解码器的唯一绝对要求是，它能够成功读取符合前面章节中指定格式的任何文件。然而，最好的结果通常是通过遵循这些建议来实现的。

##### 10.1 Error checking 错误检查

为了确保早期发现常见的文件传输问题，解码器应该验证PNG文件签名的所有八个字节都是正确的。如果接下来的八个字节是具有正确块长度的IHDR块头，则解码器可以对文件的完整性有额外的信心。

必须按照区块命名约定中所述处理未知区块类型。除非未知区块类型是关键区块，否则不会将其视为错误。

强烈建议解码器验证每个块上的CRC。

在某些情况下，在读取区块数据和CRC之前，需要检查区块头（长度和类型代码）。通过查看四个字节是否都是**ASCII字母**（代码65-90和97-122），可以**检查**块类型的合理性；请注意，这只需要对**无法识别的类型**代码执行。如果已知总文件大小（来自文件系统信息、HTTP协议等），那么也可以检查**区块长度**的**合理性**。

如果未检查CRC，那么如果有丢弃/添加的数据字节或错误的块长度可能会导致解码器失步，并将后续数据误解为块头。(CRC检查就是为了确保内容正确，侧面保证了长度正确)。在这种情况下，验证区块类型是否包含字母是提供早期错误检测的廉价方法。

对于已知长度的块（如IHDR），解码器应将意外的块长度视为错误。此规范的未来扩展不会向现有块添加新字段；而是将添加新的块类型以携带新信息。必须检查已知区块字段中的意外值（例如，IHDR区块中的意外压缩方法），并将其视为错误。但是，建议仅在关键块中将意外字段值视为致命错误。辅助块中的意外值可以通过忽略整个块来处理，就像它是未知的块类型一样。（本建议假设区块的CRC已被验证。在不检查CRC的解码器中，更安全的做法是将任何意外值视为指示文件已损坏。）

#### 10.2 像素尺寸

可以表示非方形像素（请参见pHYs区块），但不要求查看者对其进行说明。查看器可以呈现任何PNG文件，就好像它的像素是正方形一样。

相反，强烈建议在非方形像素的显示硬件上运行的显示器重新缩放图像以进行正确显示。

#### 10.3 真彩色图像处理

为了实现PNG的通用互换性目标，解码器需要接受所有类型的PNG图像：索引颜色、truecolor和灰度。在索引彩色显示硬件上运行的查看器需要能够将truecolor图像简化为索引格式进行查看。这个过程通常被称为“颜色量化”。

一种简单、快速的方法是将图像缩小为固定的调色板。具有统一颜色间距的调色板（“颜色立方体”）通常用于最小化每像素计算。对于类似照片的图像，建议使用抖动，以避免平滑渐变中的丑陋轮廓；但是，抖动会引入颗粒性，这可能会引起反感。

通过使用专门为图像选择的调色板，可以显著提高渲染质量，因为颜色立方体通常具有许多在任何特定图像中未使用的条目。这种方法需要更多的工作，首先是选择调色板，其次是将单个像素映射到最接近的可用颜色。PNG允许编码器在PLTE块中提供建议的调色板，但并非所有编码器都会这样做，并且建议的调色板在任何情况下都可能不合适（可能颜色太多或太少）。因此，高质量的观众需要手头有调色板选择程序。大型查找表通常是以足够的速度将单个像素映射到调色板条目的最可行的方法。

颜色量化的许多实现是可用的。PNG参考实现libpng包含用于此目的的代码。

#### 10.4 取样深度缩放

解码器可能希望将PNG数据缩放到较小的采样深度（数据精度）以便显示。例如，16位数据需要减少到8位深度，以便在当今大多数显示硬件上使用。将8位数据减少到5位深度也是常见的。

最精确的缩放是通过线性方程实现的

```
 output = ROUND(input * MAXOUTSAMPLE / MAXINSAMPLE)
```

这里

```
MAXINSAMPLE = (2^sampledepth)-1
MAXOUTSAMPLE = (2^desired_sampledepth)-1
```

通过简单地右移所需的采样深度位置，可以实现稍微不太精确的转换。

例如，要将16位采样减少到8位，只需丢弃低阶字节。在许多情况下，shift方法对于显示目的来说足够精确，而且肯定要快得多。（但如果正在进行伽马校正，则可以将样本重新缩放合并到伽马校正查找表中，如解码器伽马处理第10.5节所示

当存在sBIT区块时，可以通过向右移动到sBIT指定的采样深度来恢复原始PNG之前的数据。请注意，线性缩放不一定会再现原始数据，因为编码器不需要使用线性缩放来放大数据。然而，编码器需要使用保留高阶位的方法，因此移位总是有效的。这是唯一一种可以说移位比线性缩放更精确的情况。

在将像素值与tRNS块值进行比较以检测透明像素时，需要准确地进行比较。

因此，必须在降低采样精度之前进行透明像素检测。

#### 10.5 解码器伽马处理

为了产生正确的色调再现，一个好的图像显示程序应该考虑图像文件和显示设备的伽马，以及适合显示器附近照明条件的viewing_gamma 。

这可以通过计算：

```
gbright = insample / MAXINSAMPLE
bright = gbright ^ (1.0 / file_gamma)
vbright = bright ^ viewing_gamma
gcvideo = vbright ^ (1.0 / display_gamma)
fbval = ROUND(gcvideo * MAXFBVAL)
```

### 15 附录：举例CRC代码

#### Synthetic division 综合除法

$\frac{x^3 - 12x^2 - 42}{x^2 + x - 3} = x - 13 + \frac{16x - 81}{x^2 + x - 3}$

$\begin{array}{cc}     \begin{array}{rr} \\ &3 \\ -1& \\ \\ \end{array}     &     \begin{array}{|rrrr}          1 & -12 &  0 & -42 \\           &     &  3 & -39 \\           &  -1 & 13 &     \\         \hline          1 & -13 & 16 & -81 \\         \end{array} \end{array}$

#### Euclidean division of polynomials  欧几里德多项式除法

${\displaystyle {\begin{array}{r}x^{2}+{\color {White}1}x+3\\x-3\ {\overline {)\ x^{3}-2x^{2}+0x-4}}\\{\underline {x^{3}-3x^{2}{\color {White}{}+0x-4}}}\\+x^{2}+0x{\color {White}{}-4}\\{\underline {+x^{2}-3x{\color {White}{}-4}}}\\+3x-4\\{\underline {+3x-9}}\\+5\end{array}}}$

${x^3 - 2x^2 - 4} = (x-3)\,\underbrace{(x^2 + x + 3)}_{q(x)}  +\underbrace{5}_{r(x)}$

#### Polynomial short division 多项式短除法

${\displaystyle {\begin{matrix}\quad \qquad \qquad \qquad {\bcancel {x}}^{2}\quad {\bcancel {3x}}\quad 5\\\qquad \quad {\bcancel {x}}^{3}+{\bcancel {-2}}x^{2}+{\bcancel {0x}}{\bcancel {-4}}\\{\underline {\div \qquad \qquad \qquad \qquad \qquad x-3}}\\x^{2}+x+3\qquad \end{matrix}}}$



以下示例代码表示PNG块中使用的CRC（循环冗余校验）的实际实现。（正式规范另见ISO 3309[ISO-3309]或ITU-T V.42[ITU-V42]）

例代码采用ANSI C编程语言。非C用户可能会发现使用以下提示更容易阅读：

* & ：位与
* ^：异或
* \>>：右移 (应用于无符号时，左侧插入0)
* !:逻辑非运算符。
* ++：“n++”自增变量n。
* 0xNNN:0x引入十六进制（以16为基数）常量。后缀L表示长值（至少32位）

例子：

原始数据

```
11010011101100
```

求3位CRC，多项式使用 $x^3 + *x* + 1$ 即1011。步骤为 (异或)

```
11010011101100 000 <--- input right padded by 3 bits
1011               <--- divisor
01100011101100 000 <--- result (note the first four bits are the XOR with the divisor beneath, the rest of the bits are unchanged)
 1011              <--- divisor ...
00111011101100 000
  1011
00010111101100 000
   1011
00000001101100 000 <--- note that the divisor moves over to align with the next 1 in the dividend (since quotient for that step was zero)
       1011             (in other words, it doesn't necessarily move one bit per iteration)
00000000110100 000
        1011
00000000011000 000
         1011
00000000001110 000
          1011
00000000000101 000
           101 1
-----------------
00000000000000 100 <--- remainder (3 bits).  Division algorithm stops here as dividend is equal to zero.
```

由于最左边的除数位将其接触的每个输入位归零，因此当该过程结束时，输入行中唯一可以非零的位是该行右端的n位。

这n位是除法步骤的余数，也是CRC函数的值（除非所选的CRC规范要求某些后处理）。

49 48 44 52 00 00 00 54 00 00 00 53 08 02 00 00 00