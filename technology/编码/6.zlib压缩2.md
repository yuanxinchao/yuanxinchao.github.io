1.介绍

1.1 目的

本规范旨在定义无损压缩数据格式，该格式：

* 独立于CPU类型、操作系统、文件系统和字符集，因此可用于交换；
* 即使对于任意长的顺序呈现的输入数据流，也可以仅使用先验限定量的中间存储器来产生或消耗，因此可以用于数据通信或类似结构，例如Unix过滤器；
* 压缩数据的效率与当前可用的最佳通用压缩方法相当，特别是比“压缩”程序要好得多；
* 可以以专利未涵盖的方式轻松实施，因此可以自由实施；
* 与当前广泛使用的gzip实用程序生成的文件格式兼容，因为符合要求的解压缩程序将能够读取现有gzip压缩器生成的数据。

本规范定义的数据格式不会试图：

* 允许随机访问压缩数据
* 和当前可用的最佳专用算法一样压缩专用数据（如光栅图形）。

一个简单的计数参数表明，没有任何无损压缩算法可以压缩所有可能的输入数据集。对于此处定义的格式，最坏情况下的扩展是每32K字节块5个字节，即，对于大型数据集，大小增加0.015%。英文文本通常压缩2.5到3倍；可执行文件通常压缩得更少；图形数据（如光栅图像）可能会压缩得更多。

1.2 目标受众

本规范旨在供软件实施者使用，以将数据压缩为“deflate”格式和/或从“deflate”格式解压数据

本规范的文本假定在 位和其他原始数据表示级别编程的基本背景。熟悉哈夫曼编码技术是有帮助的，但不是必需的。

1.3 范围

该规范指定了一种将**字节序列**表示为（通常更短）**位序列**，然后打包为字节的方法。

1.4 合规性

除非下文另有说明，否则合规解压器必须能够接受和解压符合此处所述所有规范的任何数据集；合规压缩机必须生成符合此处所述所有规范的数据集。

1.5 使用的术语和约定的定义

字节：作为一个单位存储或传输的8位（与八位字节相同）。对于本规范，一个字节正好是8位，即使在将字符存储在不同于8位的位数上的机器上也是如此。有关字节内位的编号，请参见下文。

字符串：任意字节的序列。

1.6 与以前版本的更改

自本规范1.1版以来，deflate 格式未发生任何技术变更。在版本1.2中，一些术语被更改。版本1.3是规范到RFC样式的转换。

2.压缩表示概述

压缩数据集由一系列块组成，对应于连续的输入数据块。块大小是任意的，但不可压缩块限制为65535字节(64k)。

使用LZ77算法和哈夫曼编码的组合对每个块进行压缩。每个区块的哈夫曼树独立于先前或后续区块的哈夫曼树；LZ77算法可以使用前一个块中出现的重复字符串的引用，最大为32K。

每个块由两部分组成：一对描述压缩数据部分表示的**哈夫曼代码树**和一个**压缩数据**部分。（哈夫曼树本身使用哈夫曼编码进行压缩。）**压缩数据**由一系列两种类型的元素组成：**文字字节**（在前32K输入字节中未检测到重复的字符串）和**指向重复字符串的指针**，其中指针表示为一对<length，backward distance>。“deflate”格式中使用的表示将backward distance限制为32K字节，length限制为258字节，但不限制块的大小，不可压缩块除外，如上文所述，不可压缩块受到限制。

压缩数据中的每种类型的值（**文字**、**距离**和**长度**）都使用**哈夫曼代码**表示，文字和length使用一个代码树，backward distance使用一个**单独的代码树**。每个块的代码树以紧凑的形式出现在该块的压缩数据之前。

3.规范的细节

3.1 下图中的总体约定如下所示：

```
         +---+
         |   | <-- the vertical bars might be missing
         +---+
```

表示一个字节；像这样的盒子：

```
         +==============+
         |              |
         +==============+
```

表示可变的字节数。

存储在计算机中的字节没有“位顺序”，因为它们始终被视为一个单元。然而，一个被认为是0到255之间的整数的字节有一个最高有效位和最低有效位，因为我们写的数字的最高有效位在左边，所以我们也写的字节的最高有效位在左边。在下图中，我们对字节的位进行编号，使位0为最低有效位，即对位进行编号：

```
         +--------+
         |76543210|
         +--------+
```

在计算机中，一个数字可能占用多个字节。这里描述的格式中的所有多字节数都以最低有效字节（位于较低的内存地址）存储。例如，十进制数520存储为：

```
             0        1
         +--------+--------+
         |00001000|00000010|
         +--------+--------+
          ^        ^
          |        |
          |        + more significant byte = 2 x 256
          + less significant byte = 8
```

这里低内存地址0，存储了低有效字节 8，高内存地址1存储了高有效字节 512。这种是 least-significant byte first **LSB**。和MSB相反

3.1.1 压缩成字节

本文件不涉及字节位在位序列介质上传输的顺序问题，因为此处描述的最终数据格式是字节格式，而不是面向位的。然而，我们在下文中将压缩块格式描述为具有不同位长度的数据元素序列，而不是字节序列。因此，我们必须指定如何将这些数据元素打包成字节，以形成最终的压缩字节序列：

* 数据元素按字节内位数的递增顺序打包到字节中，即从字节的最低有效位开始。
* 哈夫曼码以外的数据元素从数据元素的最低有效位开始打包。
* 哈夫曼代码从代码的最高有效位开始打包。

换句话说，如果将压缩数据打印为一个字节序列，从*右*边的第一个字节开始，继续到*左*，每个字节的最高有效位像往常一样位于左侧，则可以从右到左解析结果，哈夫曼代码的位顺序相反

3.2 压缩块格式

3.2.1 前缀和哈夫曼编码简介

前缀编码通过位序列（代码）表示来自先验已知字母表的符号，每个符号一个代码，其方式使得不同的符号可以由不同长度的位序列表示，但是解析器始终可以逐个符号明确地解析编码字符串。

我们用二叉树定义前缀码，其中从每个非叶节点下降的两条边标记为0和1，叶节点与字母表的符号一一对应（标记为）；然后，符号的代码是从根到标有该符号的叶的边上的0和1的序列。如

```
                          /\              Symbol    Code
                         0  1             ------    ----
                        /    \                A      00
                       /\     B               B       1
                      0  1                    C     011
                     /    \                   D     010
                    A     /\
                         0  1
                        /    \
                       D      C
```

解析器可以通过在每一步选择对应于下一个输入位的边，从根沿着树向下走，从编码的输入流中解码下一个符号。

给定一个具有已知符号频率的字母表，哈夫曼算法允许构造一个最佳前缀码（该算法使用该字母表中任何可能的前缀码的最少比特来表示具有这些符号频率的字符串）。

这种代码称为哈夫曼代码。（关于哈夫曼码的更多信息，请参见第5章参考文献[1]。）

请注意，在“deflate”格式中，各种字母的哈夫曼代码不得超过某些最大代码长度。该约束使从符号频率计算代码长度的算法复杂化。请再次参阅第5章，参考资料以了解详细信息。

3.2.2. 在“deflate”格式中使用哈夫曼编码

“deflate”格式中用于每个字母表的哈夫曼代码有两个附加规则：

* 给定位长度的所有代码都具有按字典顺序排列的连续值，其顺序与其所表示的符号相同；
* 较短的代码按字典顺序先于较长的代码。

假设字母表的顺序为ABCD，我们可以按照如下规则重新编码上面的示例：

```
            Symbol  Code
            ------  ----
            A       10
            B       0
            C       110
            D       111
```

也就是说，0先于10，10先于11x，而110和111在词典上是连续的。

根据这条规则，我们可以定义字母表的哈夫曼码，只需按顺序给出字母表中每个符号的码位长度；这足以确定实际代码。在我们的示例中，代码完全由位长度序列（2、1、3、3）定义。以下算法将代码生成为整数，用于从最高有效位到最低有效位读取。代码长度初始化在tree[I].Len中；代码在tree[I].Code中生成。

1） 计算每个代码长度的代码数。设bl_count[N]表示位长度为N的值的数量，N为位长度N>=1。 bl_count[3]=5 表示3位bits的有5个值，

2） 查找每个位长度对应的最小代码的数值：MAX_BITS：最大的位数。 next_code[m]：m位比特位对应的最小值

```
                code = 0;
                bl_count[0] = 0;
                for (bits = 1; bits <= MAX_BITS; bits++) {
                    code = (code + bl_count[bits-1]) << 1;
                    next_code[bits] = code;
                }
```

3） 为所有代码指定数值，方法：使用步骤2确定的基值(next_code)，递增确定相同长度的值的所有编码。不得为从未使用过的代码（位长度为零）赋值。max_code为下例中的7(ABCDEFGH)

```
                for (n = 0;  n <= max_code; n++) {
                    len = tree[n].Len;
                    if (len != 0) {
                        tree[n].Code = next_code[len];
                        next_code[len]++;
                    }
                }
```

例子：

考虑字母ABCDEFGH，位长（3,3,3,3,3,2,4,4）。在第一步之后，我们有：

```
            N      bl_count[N]
            -      -----------
            2      1
            3      5
            4      2
```

步骤2计算next_code 代码值：

```
            N      next_code[N]
            -      ------------
            1      0
            2      0
            3      2
            4      14
```

步骤3生成以下代码值：

```
            Symbol Length   Code
            ------ ------   ----
            A       3        010
            B       3        011
            C       3        100
            D       3        101
            E       3        110
            F       2         00
            G       4       1110
            H       4       1111
```

3.2.3. 块格式的详细信息

每个压缩数据块从包含以下数据的3个头比特开始：

```
            first bit       BFINAL
            next 2 bits     BTYPE
```

请注意，头位不一定从字节边界开始，因为块不一定占用整数个字节。

当且仅当这是数据集的最后一个块时，才设置BFINAL。

BTYPE指定数据的压缩方式，如下所示：

00-无压缩

01-使用固定的哈夫曼代码进行压缩

10-使用动态哈夫曼码进行压缩

11-保留（错误）

这两种压缩情况之间的唯一区别是如何定义文字/长度和距离字母表的哈夫曼代码。

在所有情况下，实际数据的解码算法如下：

```
            do
               从输入流读取块头。
               if 存储时没有压缩
                  跳过当前部分处理字节中的任何剩余位
                  阅读LEN和NLEN（见下一节）
                  将LEN字节的数据复制到输出
               otherwise
                  if 用动态哈夫曼码压缩
                     读取代码树的表示（见下面的小节）
                  loop (直到识别出块代码结束)
                     从输入流解码文字/长度值
                     if value < 256
                        将值（文字字节）复制到输出流
                     otherwise
                        if value = end of block (256)
                           break from loop
                        otherwise (value = 257..285)
                           解码到输入流的距离

                           在输出流中向后移动距离字节，并将长度字节从此位置复制到输出流。
                  end loop
            while not last block
```

请注意，重复的字符串引用可能引用前一个块中的字符串；i、 例如，向后距离可以跨越一个或多个块边界。但是，距离不能超过输出流的开始。(使用预设字典的应用程序可能会丢弃部分输出流，距离可以引用输出流的该部分)。还要注意，引用的字符串可能与当前位置重叠；例如，如果解码的最后2个字节的值为X和Y，则<length=5，distance=2>的字符串引用会将X，Y，X，Y，X添加到输出流中。

我们现在依次指定每个压缩方法。

3.2.4 非压缩块（BTYPE=00）

直到下一个字节边界的任何输入位都将被忽略。块的其余部分由以下信息组成：

```
              0   1   2   3   4...
            +---+---+---+---+================================+
            |  LEN  | NLEN  |... LEN bytes of literal data...|
            +---+---+---+---+================================+
```

LEN是块中的数据字节数，NLEN是LEN的补码。

3.2.5. 压缩块（长度和距离代码）

如上所述，“deflate”格式的编码数据块由从三个概念上不同的字母表中提取的符号序列组成：**文字字节**[0,255]，或者从**<length，backward distance>**对 中选择，其中length：[3,258]，backward distance[1,32768]。事实上，**文字**和**length**字母表合并为一个字母表[0,285]，其中值0..255表示**文字**字节，值256表示块的**结束**，值257..285表示**长度代码**（可能与符号代码后面的额外位一起,即一个257..285里的一个值 + n个Bits的额外位就可以表里Length范围里的任意一个值），如下所示：

下面这个两个表是**共用的，固定和动态哈夫曼都会用到这两个表**

固定和动态哈夫曼先去定义长度表257-285，距离表0-29的表示，然后再从这两张表中(继续读附加位)找到对应的长度和距离。如固定哈夫曼0000001 定义为257，则遇到0000001则解释为长度表的3

**长度表**

```
                 Extra               Extra               Extra
            Code Bits Length(s) Code Bits Lengths   Code Bits Length(s)
            ---- ---- ------     ---- ---- -------   ---- ---- -------
             257   0     3       267   1   15,16     277   4   67-82
             258   0     4       268   1   17,18     278   4   83-98
             259   0     5       269   2   19-22     279   4   99-114
             260   0     6       270   2   23-26     280   4  115-130
             261   0     7       271   2   27-30     281   5  131-162
             262   0     8       272   2   31-34     282   5  163-194
             263   0     9       273   3   35-42     283   5  195-226
             264   0    10       274   3   43-50     284   5  227-257
             265   1  11,12      275   3   51-58     285   0    258
             266   1  13,14      276   3   59-66
```

额外位应解释为首先存储最高有效位的机器整数，例如，4个额外位1110表示值14。如果code为277，那么Length代表的值为67+14=81

**距离表**

```
                  Extra           Extra               Extra
             Code Bits Dist  Code Bits   Dist     Code Bits Distance
             ---- ---- ----  ---- ----  ------    ---- ---- --------
               0   0    1     10   4     33-48    20    9   1025-1536
               1   0    2     11   4     49-64    21    9   1537-2048
               2   0    3     12   5     65-96    22   10   2049-3072
               3   0    4     13   5     97-128   23   10   3073-4096
               4   1   5,6    14   6    129-192   24   11   4097-6144
               5   1   7,8    15   6    193-256   25   11   6145-8192
               6   2   9-12   16   7    257-384   26   12  8193-12288
               7   2  13-16   17   7    385-512   27   12 12289-16384
               8   3  17-24   18   8    513-768   28   13 16385-24576
               9   3  25-32   19   8   769-1024   29   13 24577-32768
```

3.2.6. 使用固定的哈夫曼码进行压缩（BTYPE=01）

这两个字母表的哈夫曼代码是固定的，在压缩数据中不会再进行定义。**文字**/**长度**(共用的)字母表的哈夫曼代码长度为：

```
                   Lit Value    Bits        Codes
                   ---------    ----        -----
                     0 - 143     8          00110000 through
                                            10111111
                   144 - 255     9          110010000 through
                                            111111111
                   256 - 279     7          0000000 through
                                            0010111
                   280 - 287     8          11000000 through
                                            11000111
```

如上所述，代码长度足以生成实际代码；为了更加清晰，我们在表中显示了代码。文字/长度值286-287实际上不会出现在压缩数据中，而是参与代码构造。

**距离**代码0-31由（固定长度）5位代码表示，可能的附加位如上面第3.2.5段所示的表格所示。请注意，距离代码30-31实际上永远不会出现在压缩数据中。



3.2.7. 使用动态哈夫曼码进行压缩（BTYPE=10)

两个字母表的哈夫曼代码出现在块中时，紧跟在头bits之后和实际压缩数据之前，首先是文字/长度代码，然后是距离代码。如上文第3.2.2段所述，每个代码由一系列代码长度定义。为了获得更大的紧凑性，使用哈夫曼码对码长序列本身进行压缩。码长的字母表如下所示：

码位长是生成的哈夫曼码占用的bit位数。

```
               0 - 15: 表示0-15的代码长度
                   16: 重复前面的码长3-6次。添加2位表示重复次数（0=3，…，3=6）
                   	   示例：代码8，16（+2位11），16（+2位10）即 {8,8,8,8...8}(1+6+5=12)个码长
                   17: 重复0码长3-10次。（附加3位 17+000-17+111）
                   18: 重复0码长11-138次（附加7位 17+0000000 - 17+1111111）
```

码长为0表示字母表中的**文字**/**长度**或**距离**中的对应符号不会出现在块中，并且不应参与前面给出的哈夫曼树代码构造算法。如果仅使用一个距离码，则使用一位而不是零位对其进行编码。一个零长度的距离码意味着根本没有使用距离码（数据都是文字表内容）。

现在我们可以定义块的格式：

```
               5 Bits: HLIT, # 文字/长度-257 （257-286）
               5 Bits: HDIST, # 距离 - 1        (1 - 32)
               4 Bits: HCLEN, # 码位长 - 4     (4 - 19)
               (HCLEN + 4) x 3 bits: 上面给出的码位长，顺序如下：
                  16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15

                  这些码位长被解释为3位整数（0-7），如上所述，
                  代码长度为0表示不使用相应的符号（文字/长度或距离）。

               HLIT + 257 长度的文字/长度字母表，使用对应码位长的哈夫曼代码编码

               HDIST + 1 长度的距离字母表，使用对应码位长哈夫曼代码编码

               块的实际压缩数据，使用文字/长度和距离的哈夫曼码进行编码

               文字/长度符号256（数据结尾），使用文字/长度哈夫曼代码编码

```

代码长度重复代码可以从HLIT+257交叉到HDIST+1代码长度。换句话说，所有代码长度形成一个HLIT+HDIST+258值的单一序列。

3.3 合规性

压缩机可进一步限制上一节中规定的数值范围，并且仍然符合要求。例如，它可以将向后指针的范围限制为小于32K的某个值。类似地，压缩器可以限制块的大小，以便可压缩块适合内存。

兼容解压缩程序必须接受上一节中定义的全部可能值，并且必须接受任意大小的块。

4.压缩算法细节